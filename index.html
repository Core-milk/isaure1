<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è‡´Isaureï¼šç”Ÿæ—¥æ˜Ÿå…‰é—ªè€€ï¼</title>

    <!-- Embedded CSS Styles -->
    <style>
        /* ... (Keep all existing CSS rules - no changes needed here for this request) ... */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap');

        :root {
            --primary-color: #ff69b4; /* Hot Pink */
            --secondary-color: #dda0dd; /* Plum */
            --accent-color: #ffd700; /* Gold */
            --text-color: #f0f8ff; /* Alice Blue */
            --bg-color-start: #1a001a; /* Deep Purple - Fallback */
            --card-bg-color: rgba(26, 0, 26, 0.7); /* More opaque card */
            --card-blur: 12px; /* Increased blur */
            --glow-intensity: 0.8; /* Glow effect intensity */
        }

        html {
            scroll-behavior: smooth;
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Noto Serif SC', serif;
            color: var(--text-color);
            background-color: var(--bg-color-start);
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        /* Three.js Canvas Styling */
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            display: block;
        }

        /* Content Overlay with gradient overlay */
        .content-overlay {
            position: relative;
            z-index: 1;
            padding-top: 5vh;
            padding-bottom: 5vh;
        }

        /* Container for centered content */
        .container {
            max-width: 850px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Enhanced Content Card Styling with Stronger Shadow */
        .content-card {
            background: var(--card-bg-color);
            border-radius: 20px;
            padding: 35px 45px;
            margin-bottom: 45px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.85); /* STRONGER SHADOW */
            backdrop-filter: blur(var(--card-blur));
            -webkit-backdrop-filter: blur(var(--card-blur));
            border: 1px solid rgba(255, 255, 255, 0.25);
            animation: fadeInCard 1.2s cubic-bezier(0.25, 1, 0.5, 1) forwards;
            opacity: 0;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .content-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,105,180,0.15) 0%, rgba(255,105,180,0) 65%);
            transform: rotate(30deg) scale(0.8);
            z-index: 0;
            opacity: 0;
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        .content-card:hover {
            box-shadow: 0 25px 65px rgba(0, 0, 0, 0.95); /* STRONGER HOVER SHADOW */
            transform: translateY(-5px);
        }

        .content-card:hover::before {
            opacity: var(--glow-intensity, 0.8);
            transform: rotate(0deg) scale(1);
        }

        /* Card Fade-in Animation */
        @keyframes fadeInCard {
            from { opacity: 0; transform: translateY(50px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* Animation Delays */
        .hero { animation-delay: 0.2s; }
        .about-her { animation-delay: 0.4s; }
        .friendship { animation-delay: 0.6s; }
        .wishes { animation-delay: 0.8s; }

        /* Enhanced Headings */
        h1, h2, h3 {
            text-align: center;
            font-weight: 700;
            letter-spacing: 1px;
            position: relative;
        }

        h1 {
            font-size: calc(2.8rem + 2vw);
            color: var(--accent-color);
            text-shadow: 0 0 15px var(--accent-color), 0 0 30px var(--primary-color), 0 0 50px var(--primary-color);
            margin-bottom: 15px;
            animation: glow 2.5s infinite alternate ease-in-out;
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            padding-bottom: 10px;
        }

        @keyframes glow {
            from { text-shadow: 0 0 15px var(--accent-color), 0 0 30px var(--primary-color), 0 0 45px var(--primary-color); filter: brightness(1); }
            to { text-shadow: 0 0 25px var(--accent-color), 0 0 50px var(--primary-color), 0 0 75px var(--primary-color); filter: brightness(1.2); }
        }

        h2 {
            font-size: calc(2rem + 1.2vw);
            color: var(--secondary-color);
            margin-top: 35px;
            margin-bottom: 30px;
            display: inline-block;
            position: relative;
            left: 50%;
            transform: translateX(-50%);
            padding: 0 20px 15px;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 10%;
            width: 80%;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
            border-radius: 3px;
            opacity: 0.8;
        }

        h2::before {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, var(--secondary-color) 0%, transparent 70%);
            filter: blur(6px);
            opacity: 0.7;
        }

        h3 {
            font-size: calc(1.4rem + 0.6vw);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            color: var(--accent-color);
        }

        /* Enhanced Paragraphs and Lists */
        p, li {
            font-size: calc(1.05rem + 0.3vw);
            line-height: 1.9;
            text-align: justify;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.75);
            margin-bottom: 20px;
            position: relative;
            color: var(--text-color);
        }

        /* Burstiness/Perplexity Styling */
        .burstiness-text p:nth-child(odd) {
            font-size: calc(1.1rem + 0.3vw);
            margin-left: 15px;
            letter-spacing: 0.5px;
            padding-left: 12px;
            border-left: 3px solid rgba(255, 105, 180, 0.4);
        }
        .burstiness-text p:nth-child(even) {
            font-size: calc(1rem + 0.3vw);
            margin-right: 15px;
            font-style: italic;
            opacity: 0.95;
            padding-right: 12px;
            border-right: 3px solid rgba(221, 160, 221, 0.4);
        }
        .burstiness-text p:last-child {
             font-weight: bold;
             color: var(--accent-color);
             text-align: center;
             font-size: calc(1.35rem + 0.4vw);
             margin-top: 35px;
             text-shadow: 0 0 15px var(--accent-color);
             animation: pulse 3s infinite ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.9; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .highlight {
            color: var(--primary-color);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.9);
            position: relative;
            display: inline-block;
            padding-bottom: 2px;
        }

        .highlight::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--primary-color);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .highlight:hover::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        .icon {
            font-size: 1.5em;
            margin-right: 8px;
            vertical-align: -0.15em;
            display: inline-block;
            filter: drop-shadow(0 0 5px var(--secondary-color));
            transition: transform 0.4s ease;
        }

        .icon:hover {
            transform: scale(1.2) rotate(10deg);
        }

        /* Enhanced Button Style */
        .cta-button {
            display: inline-block;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 16px 35px;
            border-radius: 50px;
            text-decoration: none;
            font-weight: bold;
            margin-top: 30px;
            text-align: center;
            transition: all 0.4s ease;
            box-shadow: 0 8px 25px rgba(255, 105, 180, 0.6);
            border: none;
            cursor: pointer;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
            z-index: 1;
            font-size: 1.1em;
            letter-spacing: 1px;
        }

        .cta-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
            transition: transform 0.4s ease;
            transform: scaleX(0);
            transform-origin: left;
            z-index: -1;
        }

        .cta-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(221, 160, 221, 0.8);
            color: #1a001a;
        }

        .cta-button:hover::before {
            transform: scaleX(1);
            transform-origin: left;
        }

        /* Enhanced Footer Styling */
        footer {
             text-align: center;
             padding: 25px 0;
             margin-top: 40px;
             font-size: 1em;
             color: rgba(255, 255, 255, 0.8);
             z-index: 2;
             position: relative;
             text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
             border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        footer::before {
            content: 'âœ¨';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.6em;
            filter: drop-shadow(0 0 6px var(--accent-color));
            opacity: 0.9;
            animation: footerSparkle 4s infinite ease-in-out;
        }

        @keyframes footerSparkle {
             0%, 100% { opacity: 0.7; transform: translateX(-50%) scale(1); }
             50% { opacity: 1; transform: translateX(-50%) scale(1.1); }
        }

        /* Floating Confetti Effect (CSS Only) */
        #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 10;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 15px;
            background-color: var(--primary-color);
            opacity: 0;
            animation: confetti-fall 5s linear infinite;
            transform-origin: center center;
            will-change: transform, opacity;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-10vh) rotateZ(0deg) rotateY(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) rotateZ(720deg) rotateY(360deg);
                opacity: 0;
            }
        }

        /* Tablet Optimizations */
        @media (max-width: 1024px) {
            .container { max-width: 90%; padding: 15px; }
            h1 { font-size: calc(2.5rem + 2.2vw); }
            h2 { font-size: calc(1.8rem + 1.4vw); }
            p, li { font-size: calc(1.0rem + 0.35vw); line-height: 1.85; }
            .content-card { padding: 30px 35px; margin-bottom: 40px; }
        }

        @media (max-width: 768px) {
            h1 { font-size: calc(2.3rem + 2.8vw); }
            h2 { font-size: calc(1.6rem + 1.8vw); margin-bottom: 25px;}
            p, li { font-size: calc(0.95rem + 0.45vw); line-height: 1.8; margin-bottom: 18px;}
            .content-card { padding: 25px 30px; margin-bottom: 35px;}
            .burstiness-text p:nth-child(odd) { margin-left: 10px; padding-left: 8px; }
            .burstiness-text p:nth-child(even) { margin-right: 10px; padding-right: 8px; }
            .cta-button { padding: 14px 30px; font-size: 1em; }
        }
    </style>

    <!-- Import Map for Three.js Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>

</head>
<body>

    <!-- Three.js Canvas Container -->
    <canvas id="three-canvas"></canvas>

    <!-- Confetti Container (Now styled with CSS) -->
    <div id="confetti-container"></div>

    <!-- HTML Content Overlay -->
    <div class="content-overlay">
        <div class="container">

            <!-- ç”Ÿæ—¥ç¥ç¦å¤´éƒ¨ -->
            <header class="content-card hero" id="top">
                <h1>Isaureï¼</h1>
                <p style="text-align: center; font-size: 1.3em; color: var(--secondary-color); text-shadow: 0 0 10px var(--secondary-color);">ä»Šå¤©ï¼Œå®‡å®™ä¸ºä½ ç‰¹åˆ«è°ƒäº®äº†æ˜Ÿè¾°ï¼âœ¨</p>
                <p style="text-align: center; font-style: italic; font-size: 1.1em;">è¿™ç»éæ—¥å†ä¸Šåº¸å¸¸çš„ä¸€é¡µç¿»è¿‡ï¼Œ<br>è¿™æ˜¯ç‹¬å±äºä½ çš„ï¼Œç››æ”¾çš„ï¼Œ<span class="highlight">å…‰èŠ’å››å°„</span>çš„æ—¶åˆ»ï¼</p>
                <h3 style="text-align: center; color: var(--accent-color); margin-top: 20px; animation: pulse 2s infinite;">ç”Ÿæ—¥å¿«ä¹ï¼ŒDear Isaure</h3>
            </header>

            <!-- å…³äºå¥¹çš„å…‰èŠ’ -->
            <section class="content-card about-her burstiness-text">
                <h2><span class="icon">â˜€ï¸</span>å…³äºä½ çš„å…‰èŠ’ä¸æ–‘æ–“</h2>
                <p>ä½ çš„ç¬‘é¥ï¼Œæ°ä¼¼ç››å¤ç ´æ™“æ—¶é‚£ç¬¬ä¸€ç¼•æœ€æ— é®æ‹¦çš„é˜³å…‰ï¼Œæ€»èƒ½è½»æ˜“åœ°èåŒ–ç§¯é›ªï¼Œé©±æ•£é˜´éœ¾ï¼Œæ˜åªšå¾—å«äººå¿ƒç”Ÿæš–æ„ï¼Œä¸–ç•Œä¸ºä¹‹ä¸€äº®ã€‚å¤–å‘ï¼Ÿå¼€æœ—ï¼Ÿè¿™äº›è¯è¯­å›ºç„¶æ•æ‰äº†ä½ çš„éƒ¨åˆ†å‰ªå½±ï¼Œå´åˆæ€èƒ½ç©·å°½ä½ çµé­‚æ·±å¤„é‚£è‚¡å¥”æ¶Œä¸æ¯ã€è¿‘ä¹é‡æ€§çš„ç”Ÿå‘½çƒ­åŠ›ï¼ä½ ï¼Œå°±åƒä¸€é¢—è•´è—ç€å®‡å®™æ´ªè’èƒ½é‡çš„æ˜Ÿæ ¸ï¼Œæ—¶åˆ»å‡†å¤‡ç€ï¼Œè¦çˆ†å‘å‡ºæœ€ä¸å¯æ€è®®çš„ç»šçƒ‚åå½©ã€‚</p>
                <p>æˆ‘çŸ¥é“ï¼Œè¿™ä¸–ç•Œå¹¶éæ€»æ˜¯é“ºæ»¡ç«ç‘°ä¸ä¸ç»’ï¼Œè¿™ä¸ªä¸–ç•Œå¸¦æ¥çš„é˜´å½±æˆ–è®¸æ›¾è®©ä½ æ­¥å±¥è¹’è·šï¼Œç•™ä¸‹éš¾ä»¥è¨€è¯´çš„åˆ»ç—•ã€‚ä½†è¯·ä½ çœ‹çœ‹è‡ªå·±â€”â€”çœ‹å•Šï¼é‚£äº›è¿‡å¾€çš„é£éœœï¼Œæˆ–è®¸æ›¾ç»æ‰“è´¥äº†ä½  ä½†æˆ‘æ¥äº†</p>
                <p>è€Œå½“ä½ å…¨ç„¶æ²‰æµ¸äºæŒšçˆ±ä¹‹äº‹â€”â€”<span class="icon">ğŸ¤</span>æ”¾å£°æ­Œå”±æ—¶ï¼Œé‚£æ­Œå£°ï¼Œæ—¶è€Œæ˜¯ç©¿é€äº‘éœ­çš„æ¸…å†½å±±æ³‰ï¼Œæµæ·Œç€æŠšæ…°äººå¿ƒçš„æ¸©æŸ”ï¼›æ—¶è€Œæ˜¯æ€èµ·é£æš´çš„æµ·æ½®ï¼Œè•´å«ç€éœ‡æ’¼çµé­‚çš„åŠ›é‡ï¼Œæ¯ä¸€ä¸ªéŸ³ç¬¦éƒ½ä»¿ä½›è¢«èµ‹äºˆäº†ç”Ÿå‘½ï¼Œåœ¨ç©ºæ°”ä¸­èˆè¹ˆã€å›æ—‹ã€‚<span class="icon">ğŸ¨</span>æŒ¥åŠ¨ç”»ç¬”æ—¶ï¼Œä½ çš„æŒ‡å°–ä¾¿æ‹¥æœ‰äº†ç‚¹çŸ³æˆé‡‘çš„é­”æ³•ï¼Œè‰²å½©åœ¨ä½ æ‰‹ä¸­ä¸å†ä»…ä»…æ˜¯é¢œæ–™ï¼Œå®ƒä»¬æ˜¯æƒ…ç»ªçš„è½½ä½“ï¼Œæ˜¯æ¢¦æƒ³çš„ç¢ç‰‡ï¼Œæ˜¯ä½ åœ¨ç”»å¸ƒä¸Šæ„å»ºçš„ä¸€ä¸ªåˆä¸€ä¸ªå¹³è¡Œå®‡å®™ï¼Œé‚£é‡Œå…‰é£éœæœˆï¼Œé¸Ÿè¯­èŠ±é¦™ï¼Œæ˜¯ä½ å†…å¿ƒæ·±å¤„ä¸ç­çš„ç†æƒ³å›½ã€‚</p>
                <p>ä½ çš„æ‰åï¼Œä¸æ˜¯å­¤èŠ³è‡ªèµçš„æ°´ä»™ï¼Œè€Œæ˜¯é»‘å¤œä¸­æŒ‡å¼•èˆªèˆ¹çš„ç¯å¡”ï¼Œæ—¢ç…§äº®äº†è‡ªå·±å‰è¡Œçš„è·¯ï¼Œä¹Ÿæ¸©æš–äº†æ‰€æœ‰é è¿‘ä½ çš„äººã€‚</p>
            </section>

            <!-- æˆ‘ä»¬çš„å‹è°Š -->
            <section class="content-card friendship burstiness-text">
                <h2><span class="icon">ğŸ’–</span>æˆ‘ä»¬ä¹‹é—´ï¼Œæ˜¯è¶…è¶Šå®šä¹‰çš„ç¾ç»Š</h2>
                <p>æˆ‘ä»¬æ›¾å¹¶è‚©ä½œæˆ˜ã€æŠµå¾¡é£æµªçš„åŒè¢ï¼Œé‚£äº›ä¸€èµ·ç†¬è¿‡çš„å¤œï¼Œä¸€èµ·æ”»å…‹çš„éš¾å…³ï¼Œéƒ½å·²åŒ–ä½œå½¼æ­¤å¿ƒä¸­æ— éœ€è¨€è¯´çš„é»˜å¥‘ï¼›æˆ‘ä»¬æ›´æ˜¯äº¤æ¢å¿ƒäº‹ã€åˆ†äº«è„†å¼±çš„çŸ¥å·±ï¼Œé‚£äº›æ·±å¤œæœˆå…‰ä¸‹çš„çªƒçªƒç§è¯­ï¼Œé‚£äº›åªæœ‰æˆ‘ä»¬æ‰æ‡‚çš„æ¢—å’Œç¬é—´ï¼Œæ—©å·²æˆä¸ºçµé­‚æ·±å¤„æœ€æ¸©æš–çš„ç§˜è—ã€‚çŸ¥é“å—ï¼Ÿæ— è®ºé¡ºå¢ƒé€†æ—…ï¼Œæ€»æœ‰ä¸€ä¸ªè§’è½ä¸ºä½ ç•™ç€ï¼Œæ€»æœ‰ä¸€ä¸ªå£°éŸ³å¯¹ä½ è¯´ï¼š"æˆ‘æ°¸è¿œæ‡‚ä½  æŠ±æŠ±"</p>
                <p>æ˜¯ä½ ï¼Œæ•™ä¼šæˆ‘é‡Šæ”¾å‹åŠ›ï¼›ä¹Ÿæ˜¯ä½ ï¼Œè®©æˆ‘æ·±åˆ»ä½“ä¼šåˆ°ï¼Œå³ä¾¿èº«å¤„å¹½è°·ï¼Œä¹Ÿè¦æ°¸è¿œå‘ç€é˜³å…‰çš„æ–¹å‘ï¼Œå€”å¼ºç”Ÿé•¿ã€‚ä½ åœ¨æˆ‘ç»æœ›çš„æ—¶å€™ä»æ·±æ¸Šä¸­æŠŠæˆ‘æ‹‰èµ·ï¼Œç”šè‡³ä¸æƒœè‡ªå·±ã€‚è¿™ä»½å‹è°Šï¼Œå®ƒåšéŸ§è¿‡æœ€ç¡¬çš„é’»çŸ³ï¼Œæ¸©æš–è¿‡å†¬æ—¥çš„ç‚‰ç«ï¼Œçº¯ç²¹è¿‡åˆç”Ÿçš„æœéœ²â€”â€”èƒ½é‡è§ä½ ï¼Œæ˜¯æˆ‘æ­¤ç”Ÿä½•å…¶å¹¸é‹çš„æ©å…¸ã€‚çœŸçš„ï¼Œåƒè¨€ä¸‡è¯­ï¼Œæ±‡æˆä¸€å¥ï¼šè°¢è°¢ä½ ï¼Œå‡ºç°åœ¨æˆ‘çš„ç”Ÿå‘½é‡Œï¼</p>
                <p>è¿™ä»½æƒ…è°Šï¼Œæ—©å·²è¶…è¶Š"å‹è°Š"äºŒå­—çš„ç®€å•ç•Œå®šï¼Œå®ƒæ˜¯ä¸€ç§æ·±åˆ»ã€å¤æ‚çš„çš„è¿æ¥ï¼Œä¸€ç§çµé­‚çš„å›å“ï¼Œåœ¨å²æœˆçš„é•¿æ²³é‡Œç† ç† ç”Ÿè¾‰ï¼Œå†ä¹…å¼¥åšã€‚</p>
            </section>

            <!-- æ¸©æŸ”çš„é¼“åŠ±ä¸ç¥ç¦ -->
            <section class="content-card wishes burstiness-text">
                <h2><span class="icon">ğŸŒŸ</span>æ„¿ä½ çš„ä¸–ç•Œï¼Œä»æ­¤æ™´ç©ºä¸‡é‡Œï¼Œç¹èŠ±ä¼¼é”¦</h2>
                <p>Dear Isaureï¼Œæˆ‘çŸ¥é“çš„ï¼Œç”Ÿæ´»è¿™æœ¬åšé‡çš„ä¹¦ï¼Œå¹¶éæ¯ä¸€é¡µéƒ½å†™æ»¡äº†è¯—æƒ…ç”»æ„ã€‚é‚£äº›ä¸æœŸè€Œè‡³çš„é£é›¨ï¼Œé‚£äº›æ²‰ç”¸ç”¸å‹åœ¨å¿ƒå¤´çš„å¾€äº‹ï¼Œæˆ–è®¸è®©ä½ æ„Ÿåˆ°ç–²æƒ«ï¼Œç”šè‡³å¶æœ‰ç¬é—´çš„é»¯æ·¡ã€‚ä½†è¯·ä½ åŠ¡å¿…åšä¿¡â€”â€”ä½ å†…åœ¨è•´è—çš„é‚£æŸå…‰ï¼Œé‚£ç‹¬ä¸€æ— äºŒçš„çµé­‚ç«ç„°ï¼Œä»æœªæœ‰ç†„ç­ï¼å³ä¾¿ä»–ä¼¼ä¹å¿«è¦ç†„ç­äº†ï¼Œæˆ‘å“ªæ€•å°†è‡ªå·±ä½œä¸ºé‚£äº›è±†èï¼Œä¹Ÿè¦å°†ä½ æ¨å‘ç¾å¥½çš„æœªæ¥ã€‚</p>
                <p>è¿‡å»çš„ä¼¤ç—•ï¼Œå®ƒä»¬å¡‘é€ äº†ä½ çš„ä¸€éƒ¨åˆ†ï¼Œå´ç»ä¸èƒ½å®šä¹‰ä½ çš„å…¨éƒ¨ï¼ä½ é‚£é¢—å¼ºå¤§è€Œæ¸©æŸ”çš„å¿ƒï¼Œä½ å¯¹è‰ºæœ¯ä¸ç¾çš„æ‰§ç€çƒ­çˆ±ï¼Œä½ åˆ›é€ å¿«ä¹ã€æ„ŸæŸ“ä»–äººçš„éå‡¡èƒ½åŠ›â€”â€”è¿™ï¼Œè¿™æ‰æ˜¯ä½ æœ€çœŸå®ã€æœ€å®è´µçš„å†…æ ¸ï¼æ˜¯é‚£ä¸ªå”±æ­Œæ—¶çœ¼é‡Œæœ‰æ˜Ÿæ²³ç’€ç’¨ï¼Œç”»ç”»æ—¶æŒ‡å°–æœ‰è¶èˆç¿©è·¹çš„ä½ ï¼ä¸è¦ï¼Œæ°¸è¿œä¸è¦è®©ä»»ä½•é˜´éœ¾é®è”½äº†ä½ çœºæœ›è¿œæ–¹çš„è§†çº¿ã€‚ä½ çœ‹ï¼Œå‰æ–¹æ˜¯å¤šä¹ˆè¾½é˜”æ— å çš„å¤©åœ°ï¼Œæ­£ç­‰å¾…ä½ ç”¨æœ€å˜¹äº®çš„æ­Œå£°å»å›åº”ï¼Œç”¨æœ€ç»šçƒ‚çš„è‰²å½©å»æç»˜ï¼å»æ‹¥æŠ±ï¼å»å¾æœï¼</p>
                <p>æ‰€ä»¥ï¼Œä»Šå¤©ï¼Œè¿™ä¸ªç‰¹æ®Šçš„æ—¥å­ï¼Œä»¥åŠæœªæ¥æ¯ä¸€ä¸ªå€¼å¾—åº†ç¥çš„å¹³å‡¡ç¬é—´ï¼Œè¯·ä½ <span class="highlight">æ— æ‰€é¡¾å¿Œåœ°æ”¾å£°æ­Œå”±å§ï¼æ·‹æ¼“å°½è‡´åœ°æŒ¥æ´’ä½ çš„è‰²å½©å§ï¼</span>å»åšä¸€åˆ‡èƒ½ç‚¹ç‡ƒä½ çƒ­æƒ…ã€è®©ä½ å¿ƒè·³æ¼æ‰åŠæ‹ã€è®©ä½ å˜´è§’ä¸è‡ªè§‰ä¸Šæ‰¬çš„äº‹æƒ…ï¼å‹‡æ•¢å»çˆ±ï¼Œçƒ­çƒˆå»æ„Ÿå—ï¼Œå¤§èƒ†å»åˆ›é€ ï¼Œä¹¦å†™åªå±äºä½ çš„ã€ç‹¬ä¸€æ— äºŒçš„ç”Ÿå‘½ä¼ å¥‡ï¼</p>
                <p>æ„¿å¿«ä¹ä»æ­¤æˆä¸ºä½ çš„æ—¥å¸¸æ ‡é…ï¼Œåƒç©ºæ°”ä¸€æ ·æ— å¤„ä¸åœ¨ï¼›æ„¿æ¸©æš–æ—¶åˆ»å°†ä½ ç´§ç´§ç¯ç»•ï¼Œå¦‚åŒæœ€è´´èº«çš„æ‹¥æŠ±ï¼›æ„¿ä¸–é—´æ‰€æœ‰ä¸æœŸè€Œé‡çš„ç¾å¥½ï¼Œéƒ½äº‰å…ˆæååœ°å‘ä½ å¥”æ¶Œè€Œæ¥ï¼Œæ±‡èšæˆå¹¸ç¦çš„æµ·æ´‹ï¼æ„¿ä½ çš„æ¯ä¸€å¤©ï¼Œéƒ½å……æ»¡æ„æƒ³ä¸åˆ°çš„æƒŠå–œä¸ä¸å®¹ç½®ç–‘çš„å¥½è¿ï¼<br>ç”Ÿæ—¥å¿«ä¹ï¼Œæˆ‘å¿ƒä¸­æ— å¯æ›¿ä»£çš„Isaureï¼<br>æ„¿ä½ çš„ä¸–ç•Œï¼Œè‡ªæ­¤åªæœ‰æ–‘æ–“è‰²å½©ï¼Œå†æ— ä¸€ä¸é˜´éœ¾ï¼</p>
                <div style="text-align: center;">
                    <a href="#top" class="cta-button" onclick="document.getElementById('top').scrollIntoView({ behavior: 'smooth' }); return false;">å›åˆ°æ˜Ÿå…‰ä¹‹å·…ï¼</a>
                </div>
            </section>

            <!-- é¡µè„š -->
             <footer>
                ç”¨æ¼«å¤©æ˜Ÿè¾°ä½œå¢¨ï¼Œå†™ä¸‹è¿™ä»½ç¥ç¦ï¼Œ<br>
                é€ç»™ç‹¬ä¸€æ— äºŒçš„ä½ ï¼Œæˆ‘æœ€å¥½çš„æœ‹å‹ã€‚
            </footer>
             <p style="font-size: 0.65em; /* è°ƒæ•´ä¸ºä½ æƒ³è¦çš„ç²¾ç¡®å¤§å° */
                      color: rgba(255, 255, 255, 0.7); /* ç™½è‰²å¸¦ä¸€ç‚¹é€æ˜ */
                      text-align: center;
                      margin-top: 20px; /* ä¸é¡µè„šçš„è·ç¦» */
                      padding-bottom: 15px; /* è·ç¦»é¡µé¢åº•éƒ¨çš„è·ç¦» */
                      opacity: 0.8; /* è½»å¾®é€æ˜ */
                      letter-spacing: 0.5px; /* è½»å¾®å¢åŠ å­—é—´è· */
                      position: relative; /* ç¡®ä¿åœ¨canvasä¹‹ä¸Š */
                      z-index: 2;">
                æœ€å You're the only one I want to give the most affection to.
            </p>
        </div>
    </div>

    <!-- Embedded Three.js Script (Module Type) -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // Scene Setup
        const scene = new THREE.Scene();
        const canvas = document.getElementById('three-canvas');
        let renderer, composer, bloomPass;
        let textMesh = null;

        try {
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true, // Enable basic anti-aliasing
                alpha: true,
                powerPreference: "high-performance"
            });
            // --- MODIFICATION: Use full device pixel ratio for potentially higher res rendering ---
            // Note: Can impact performance on high-DPI screens. Keep Math.min(..., 2) for balance if needed.
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding; // Correct color space
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better contrast and highlights
            renderer.toneMappingExposure = 1.2;

            // --- MODIFICATION: Enable Shadow Mapping ---
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadow edges

        } catch (error) {
            console.error("WebGL is not supported or renderer initialization failed:", error);
            const overlay = document.querySelector('.content-overlay');
            if (overlay) overlay.style.display = 'none';
            document.body.innerHTML = "<div style='color:white; text-align:center; padding: 50px; font-size: 1.2em; font-family: sans-serif;'>æŠ±æ­‰ï¼Œæ‚¨çš„è®¾å¤‡ä¼¼ä¹ä¸æ”¯æŒåˆ›å»ºè¿™ä¸ª3Dæ•ˆæœæ‰€éœ€çš„æŠ€æœ¯(WebGL)ã€‚<br>ä½†è¿™ä»½ç”Ÿæ—¥ç¥ç¦çš„å¿ƒæ„ä¸å˜ï¼ç”Ÿæ—¥å¿«ä¹ï¼ŒIsaureï¼</div>" + (overlay ? overlay.outerHTML : '');
            if(canvas) canvas.style.display = 'none';
            throw new Error("Renderer failed to initialize.");
        }

        // Camera
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 15, 70);

        // Enhanced Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.04;
        controls.enableZoom = true;
        controls.zoomSpeed = 0.6;
        controls.enablePan = false; // Keep pan disabled for this effect
        controls.minDistance = 25;
        controls.maxDistance = 180;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.4;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.minPolarAngle = Math.PI * 0.15;

        // Enhanced Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Slightly reduced ambient intensity
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xff69b4, 450, 350, 1.8); // Pink
        pointLight1.position.set(80, 60, 80);
        // --- MODIFICATION: Enable Shadow Casting for this light ---
        pointLight1.castShadow = true;
        pointLight1.shadow.mapSize.width = 1024; // Shadow map resolution (power of 2)
        pointLight1.shadow.mapSize.height = 1024;
        pointLight1.shadow.camera.near = 10;    // Adjust shadow camera frustum
        pointLight1.shadow.camera.far = 400;
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xdda0dd, 350, 300, 1.8); // Plum
        pointLight2.position.set(-80, -60, 60);
        // pointLight2.castShadow = true; // Optional: Enable shadows for more lights (costly)
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0xffd700, 300, 300, 1.8); // Gold
        pointLight3.position.set(0, -70, 120);
        // pointLight3.castShadow = true; // Optional
        scene.add(pointLight3);

        // Add light halos (these don't cast shadows)
        const lightHalo1 = createLightHalo(0xff69b4, 18);
        lightHalo1.position.copy(pointLight1.position);
        scene.add(lightHalo1);
        const lightHalo2 = createLightHalo(0xdda0dd, 15);
        lightHalo2.position.copy(pointLight2.position);
        scene.add(lightHalo2);
        const lightHalo3 = createLightHalo(0xffd700, 12);
        lightHalo3.position.copy(pointLight3.position);
        scene.add(lightHalo3);

        function createLightHalo(color, size) {
            const geometry = new THREE.SphereGeometry(size, 32, 16);
            const material = new THREE.MeshBasicMaterial({ // Basic material ignores light/shadow
                color: color,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            return new THREE.Mesh(geometry, material);
        }

        // Post-processing Effects
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.3, // strength
            0.5, // radius
            0.75 // threshold
        );
        composer.addPass(bloomPass);


        // Create a galaxy of particles (Particles generally don't cast/receive shadows well)
        const particleCount = 15000;
        const particlesGeometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);
        const colorArray = new Float32Array(particleCount * 3);
        const sizeArray = new Float32Array(particleCount);

        const colorPalette = [
            new THREE.Color(0xff69b4), new THREE.Color(0xdda0dd), new THREE.Color(0xffd700),
            new THREE.Color(0x9370db), new THREE.Color(0xffffff)
        ];

        for(let i = 0; i < particleCount; i++) {
            // ... (particle position, color, size calculation - same as before) ...
            const i3 = i * 3;
            const radius = 180 + Math.random() * 400;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray[i3] = radius * Math.sin(phi) * Math.cos(theta);
            posArray[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            posArray[i3 + 2] = radius * Math.cos(phi);
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            const finalColor = Math.random() < 0.3 ? (Math.random() < 0.5 ? colorPalette[4] : colorPalette[2]) : color;
            colorArray[i3] = finalColor.r;
            colorArray[i3 + 1] = finalColor.g;
            colorArray[i3 + 2] = finalColor.b;
            sizeArray[i] = Math.random() * 2.8 + 0.7;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));

        const particleMaterial = new THREE.PointsMaterial({
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
            map: createSparkleTexture(),
            depthWrite: false, // Important for blending
            alphaTest: 0.01
        });

        const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particleSystem);

        // Create floating 3D text
        const textLoader = new FontLoader();
        textLoader.load(
            'https://unpkg.com/three@0.163.0/examples/fonts/helvetiker_regular.typeface.json',
            function ( font ) {
                const textGeometry = new TextGeometry( 'Happy Birthday', {
                    font: font,
                    size: 8,
                    height: 1.5, // Depth of the text
                    curveSegments: 16, // Increased smoothness
                    bevelEnabled: true,
                    bevelThickness: 0.6,
                    bevelSize: 0.3,
                    bevelOffset: 0,
                    bevelSegments: 8 // Increased bevel smoothness
                });
                textGeometry.center(); // Center the geometry origin
                // --- MODIFICATION: Use MeshStandardMaterial for light interaction ---
                const textMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff69b4, // Base color
                    emissive: 0xdda0dd, // Glow color
                    emissiveIntensity: 0.3, // Reduced intensity, let light do more work
                    metalness: 0.4, // Make it slightly metallic
                    roughness: 0.5, // Control shininess
                });
                textMesh = new THREE.Mesh( textGeometry, textMaterial );
                textMesh.position.set(0, 0, -20); // Position closer to camera
                // --- MODIFICATION: Enable Shadow Casting for Text ---
                textMesh.castShadow = true;
                // textMesh.receiveShadow = true; // Optional: text can receive shadows too
                scene.add( textMesh );
            },
            function ( xhr ) { console.log( (xhr.loaded / xhr.total * 100) + '% font loaded' ); },
            function ( err ) { console.error( 'An error happened during font loading:', err ); }
        );


        // Create floating shapes (True 3D Models)
        const shapesGroup = new THREE.Group();
        const shapeGeometries = [
             new THREE.IcosahedronGeometry(3.5, 1), // Increased detail
             new THREE.TorusKnotGeometry(2.5, 0.8, 128, 16), // Increased detail
             new THREE.OctahedronGeometry(3, 1) // Increased detail
             // Add more complex geometries if desired:
             // new THREE.DodecahedronGeometry(3, 0),
             // new THREE.TorusGeometry(2.5, 1, 16, 100)
        ];
        const shapesCount = 35;

        for(let i = 0; i < shapesCount; i++) {
             const geometry = shapeGeometries[i % shapeGeometries.length];
             // --- MODIFICATION: Consistently use MeshStandardMaterial ---
             const material = new THREE.MeshStandardMaterial({
                color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                // emissive: 0x050505, // Very slight self-glow if desired
                metalness: Math.random() * 0.6, // Variable metalness
                roughness: Math.random() * 0.7 + 0.1, // Variable roughness (0=shiny, 1=matte)
                transparent: true,
                opacity: 0.88 + Math.random() * 0.12, // Slightly less transparent
                // wireframe: Math.random() > 0.9 // Less wireframe, make them solid
            });
            const shape = new THREE.Mesh(geometry, material);
            const radius = 50 + Math.random() * 80;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            shape.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // --- MODIFICATION: Enable Shadow Casting for Shapes ---
            shape.castShadow = true;
            // shape.receiveShadow = true; // Optional: shapes can receive shadows (can be costly)

            shape.userData = {
                orbitSpeed: (Math.random() - 0.5) * 0.01,
                rotationSpeed: (Math.random() - 0.5) * 0.025,
                bobSpeed: Math.random() * 0.8 + 0.4,
                amplitude: Math.random() * 4 + 2,
                initialPosition: shape.position.clone()
            };
            shapesGroup.add(shape);
        }
        scene.add(shapesGroup);

        // --- Balloons Setup ---
        const balloonsGroup = new THREE.Group();
        const balloonCount = 25;
        const balloonColors = [0xff69b4, 0xdda0dd, 0xffd700, 0x87cefa, 0x98fb98];
        const balloonSpawnArea = 150;
        const balloonMaxHeight = 250;
        const balloonMinHeight = -150;

        // --- Create Balloons Function ---
        function createBalloons() {
            const balloonGeometry = new THREE.SphereGeometry(2.5, 32, 24); // Increased segments
            balloonGeometry.scale(1, 1.25, 1); // Slightly taller

            for (let i = 0; i < balloonCount; i++) {
                 // --- MODIFICATION: Use MeshStandardMaterial for better lighting ---
                const balloonMaterial = new THREE.MeshStandardMaterial({
                    color: balloonColors[Math.floor(Math.random() * balloonColors.length)],
                    metalness: 0.1,  // Less metallic than shapes
                    roughness: 0.6,  // Rougher surface, less shiny like rubber/plastic
                    transparent: true,
                    opacity: 0.9, // Slightly more opaque
                    // emissive: 0x080808, // Tiny bit of self light if desired
                });

                const balloon = new THREE.Mesh(balloonGeometry, balloonMaterial);

                balloon.position.x = (Math.random() - 0.5) * balloonSpawnArea;
                balloon.position.z = (Math.random() - 0.5) * balloonSpawnArea;
                balloon.position.y = balloonMinHeight + Math.random() * 100;

                // --- MODIFICATION: Enable Shadow Casting for Balloons ---
                balloon.castShadow = true;
                // balloon.receiveShadow = true; // Optional

                balloon.userData = {
                    baseYSpeed: Math.random() * 0.08 + 0.05,
                    driftSpeedX: Math.random() * 0.5 + 0.2,
                    driftSpeedZ: Math.random() * 0.5 + 0.2,
                    driftAmplitudeX: Math.random() * 0.05 + 0.02,
                    driftAmplitudeZ: Math.random() * 0.05 + 0.02,
                    initialPhaseX: Math.random() * Math.PI * 2,
                    initialPhaseZ: Math.random() * Math.PI * 2
                };

                balloonsGroup.add(balloon);
            }
            scene.add(balloonsGroup);
        }


        // Helper function to create particle texture
        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; // Good resolution
            canvas.height = 128;
            const context = canvas.getContext('2d');
            if (!context) return null;
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.15, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // Animation loop
        const clock = new THREE.Clock();
        const rotationAxis = new THREE.Vector3(0, 1, 0);

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();

            // Animate Particles
            particleSystem.rotation.y = elapsedTime * 0.015;
            particleSystem.rotation.x = elapsedTime * 0.008;

            // Animate Shapes
            shapesGroup.children.forEach(shape => {
                const { orbitSpeed, rotationSpeed, bobSpeed, amplitude, initialPosition } = shape.userData;
                shape.position.applyAxisAngle(rotationAxis, orbitSpeed * deltaTime * 60);
                shape.position.y += Math.sin(elapsedTime * bobSpeed + initialPosition.x) * amplitude * deltaTime * 1.5;
                shape.rotation.x += rotationSpeed * deltaTime * 60;
                shape.rotation.y += rotationSpeed * 0.5 * deltaTime * 60;
                shape.rotation.z += rotationSpeed * 0.3 * deltaTime * 60;
            });

             // Animate Text
             if (textMesh) {
                 textMesh.rotation.y = Math.sin(elapsedTime * 0.3) * 0.15;
                 textMesh.position.y = Math.sin(elapsedTime * 0.5) * 1.5;
             }

             // Animate Balloons
             balloonsGroup.children.forEach(balloon => {
                 const ud = balloon.userData;
                 balloon.position.y += ud.baseYSpeed * deltaTime * 60;
                 balloon.position.x += Math.sin(elapsedTime * ud.driftSpeedX + ud.initialPhaseX) * ud.driftAmplitudeX * deltaTime * 60;
                 balloon.position.z += Math.cos(elapsedTime * ud.driftSpeedZ + ud.initialPhaseZ) * ud.driftAmplitudeZ * deltaTime * 60;
                 if (balloon.position.y > balloonMaxHeight) {
                     balloon.position.y = balloonMinHeight - Math.random() * 20;
                     balloon.position.x = (Math.random() - 0.5) * balloonSpawnArea;
                     balloon.position.z = (Math.random() - 0.5) * balloonSpawnArea;
                     ud.initialPhaseX = Math.random() * Math.PI * 2;
                     ud.initialPhaseZ = Math.random() * Math.PI * 2;
                 }
             });

            // Update controls
            controls.update();

            // Render using composer (includes bloom)
            composer.render();
            // If NOT using composer, render directly: renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            // --- MODIFICATION: Update pixel ratio on resize too ---
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        // Create CSS confetti (unrelated to 3D rendering)
        function createConfetti() {
            // ... (confetti creation code remains the same) ...
            const container = document.getElementById('confetti-container');
            if (!container) return;
            const colors = ['#ff69b4', '#dda0dd', '#ffd700', '#9370db', '#ffffff'];
            const count = 150;
            container.innerHTML = ''; // Clear previous
            for(let i = 0; i < count; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                const isRect = Math.random() > 0.5;
                confetti.style.width = Math.random() * (isRect ? 8 : 12) + 5 + 'px';
                confetti.style.height = Math.random() * (isRect ? 12 : 8) + 5 + 'px';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.opacity = Math.random() * 0.5 + 0.5;
                confetti.style.animationDuration = Math.random() * 4 + 3 + 's';
                confetti.style.animationDelay = Math.random() * 6 + 's';
                container.appendChild(confetti);
            }
        }

        // Start
        try {
            createBalloons(); // Create balloons first
            animate();        // Start animation loop
            createConfetti(); // Create CSS confetti
        } catch(error) {
             console.error("Error starting animation or effects:", error);
             // Fallback handled during renderer init
        }

    </script>

</body>
</html>