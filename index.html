<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è‡´Isaureï¼šç”Ÿæ—¥æ˜Ÿå…‰é—ªè€€ï¼</title>

    <!-- Embedded CSS Styles -->
    <style>
        /* ... (Keep all existing CSS rules - no changes needed here for this request) ... */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap');

        :root {
            --primary-color: #ff69b4; /* Hot Pink */
            --secondary-color: #dda0dd; /* Plum */
            --accent-color: #ffd700; /* Gold */
            --text-color: #f0f8ff; /* Alice Blue */
            --bg-color-start: #1a001a; /* Deep Purple - Fallback */
            --card-bg-color: rgba(26, 0, 26, 0.7); /* More opaque card */
            --card-blur: 12px; /* Increased blur */
            --glow-intensity: 0.8; /* Glow effect intensity */
        }

        html {
            scroll-behavior: smooth;
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Noto Serif SC', serif;
            color: var(--text-color);
            background-color: var(--bg-color-start);
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        /* Three.js Canvas Styling */
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            display: block;
        }

        /* Content Overlay with gradient overlay */
        .content-overlay {
            position: relative;
            z-index: 1;
            padding-top: 5vh;
            padding-bottom: 5vh;
        }

        /* Container for centered content */
        .container {
            max-width: 850px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Enhanced Content Card Styling with Stronger Shadow */
        .content-card {
            background: var(--card-bg-color);
            border-radius: 20px;
            padding: 35px 45px;
            margin-bottom: 45px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.85); /* STRONGER SHADOW */
            backdrop-filter: blur(var(--card-blur));
            -webkit-backdrop-filter: blur(var(--card-blur));
            border: 1px solid rgba(255, 255, 255, 0.25);
            animation: fadeInCard 1.2s cubic-bezier(0.25, 1, 0.5, 1) forwards;
            opacity: 0;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .content-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,105,180,0.15) 0%, rgba(255,105,180,0) 65%);
            transform: rotate(30deg) scale(0.8);
            z-index: 0;
            opacity: 0;
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        .content-card:hover {
            box-shadow: 0 25px 65px rgba(0, 0, 0, 0.95); /* STRONGER HOVER SHADOW */
            transform: translateY(-5px);
        }

        .content-card:hover::before {
            opacity: var(--glow-intensity, 0.8);
            transform: rotate(0deg) scale(1);
        }

        /* Card Fade-in Animation */
        @keyframes fadeInCard {
            from { opacity: 0; transform: translateY(50px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* Animation Delays */
        .hero { animation-delay: 0.2s; }
        .about-her { animation-delay: 0.4s; }
        .friendship { animation-delay: 0.6s; }
        .wishes { animation-delay: 0.8s; }

        /* Enhanced Headings */
        h1, h2, h3 {
            text-align: center;
            font-weight: 700;
            letter-spacing: 1px;
            position: relative;
        }

        h1 {
            font-size: calc(2.8rem + 2vw);
            color: var(--accent-color);
            text-shadow: 0 0 15px var(--accent-color), 0 0 30px var(--primary-color), 0 0 50px var(--primary-color);
            margin-bottom: 15px;
            animation: glow 2.5s infinite alternate ease-in-out;
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            padding-bottom: 10px;
        }

        @keyframes glow {
            from { text-shadow: 0 0 15px var(--accent-color), 0 0 30px var(--primary-color), 0 0 45px var(--primary-color); filter: brightness(1); }
            to { text-shadow: 0 0 25px var(--accent-color), 0 0 50px var(--primary-color), 0 0 75px var(--primary-color); filter: brightness(1.2); }
        }

        h2 {
            font-size: calc(2rem + 1.2vw);
            color: var(--secondary-color);
            margin-top: 35px;
            margin-bottom: 30px;
            display: inline-block;
            position: relative;
            left: 50%;
            transform: translateX(-50%);
            padding: 0 20px 15px;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 10%;
            width: 80%;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
            border-radius: 3px;
            opacity: 0.8;
        }

        h2::before {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, var(--secondary-color) 0%, transparent 70%);
            filter: blur(6px);
            opacity: 0.7;
        }

        h3 {
            font-size: calc(1.4rem + 0.6vw);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            color: var(--accent-color);
        }

        /* Enhanced Paragraphs and Lists */
        p, li {
            font-size: calc(1.05rem + 0.3vw);
            line-height: 1.9;
            text-align: justify;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.75);
            margin-bottom: 20px;
            position: relative;
            color: var(--text-color);
        }

        /* Burstiness/Perplexity Styling */
        .burstiness-text p:nth-child(odd) {
            font-size: calc(1.1rem + 0.3vw);
            margin-left: 15px;
            letter-spacing: 0.5px;
            padding-left: 12px;
            border-left: 3px solid rgba(255, 105, 180, 0.4);
        }
        .burstiness-text p:nth-child(even) {
            font-size: calc(1rem + 0.3vw);
            margin-right: 15px;
            font-style: italic;
            opacity: 0.95;
            padding-right: 12px;
            border-right: 3px solid rgba(221, 160, 221, 0.4);
        }
        .burstiness-text p:last-child {
             font-weight: bold;
             color: var(--accent-color);
             text-align: center;
             font-size: calc(1.35rem + 0.4vw);
             margin-top: 35px;
             text-shadow: 0 0 15px var(--accent-color);
             animation: pulse 3s infinite ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.9; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .highlight {
            color: var(--primary-color);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.9);
            position: relative;
            display: inline-block;
            padding-bottom: 2px;
        }

        .highlight::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--primary-color);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .highlight:hover::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        .icon {
            font-size: 1.5em;
            margin-right: 8px;
            vertical-align: -0.15em;
            display: inline-block;
            filter: drop-shadow(0 0 5px var(--secondary-color));
            transition: transform 0.4s ease;
        }

        .icon:hover {
            transform: scale(1.2) rotate(10deg);
        }

        /* Enhanced Button Style */
        .cta-button {
            display: inline-block;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 16px 35px;
            border-radius: 50px;
            text-decoration: none;
            font-weight: bold;
            margin-top: 30px;
            text-align: center;
            transition: all 0.4s ease;
            box-shadow: 0 8px 25px rgba(255, 105, 180, 0.6);
            border: none;
            cursor: pointer;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
            z-index: 1;
            font-size: 1.1em;
            letter-spacing: 1px;
        }

        .cta-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
            transition: transform 0.4s ease;
            transform: scaleX(0);
            transform-origin: left;
            z-index: -1;
        }

        .cta-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(221, 160, 221, 0.8);
            color: #1a001a;
        }

        .cta-button:hover::before {
            transform: scaleX(1);
            transform-origin: left;
        }

        /* Enhanced Footer Styling */
        footer {
             text-align: center;
             padding: 25px 0;
             margin-top: 40px;
             font-size: 1em;
             color: rgba(255, 255, 255, 0.8);
             z-index: 2;
             position: relative;
             text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
             border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        footer::before {
            content: 'âœ¨';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.6em;
            filter: drop-shadow(0 0 6px var(--accent-color));
            opacity: 0.9;
            animation: footerSparkle 4s infinite ease-in-out;
        }

        @keyframes footerSparkle {
             0%, 100% { opacity: 0.7; transform: translateX(-50%) scale(1); }
             50% { opacity: 1; transform: translateX(-50%) scale(1.1); }
        }

        /* Floating Confetti Effect (CSS Only) */
        #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 10;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 15px;
            background-color: var(--primary-color);
            opacity: 0;
            animation: confetti-fall 5s linear infinite;
            transform-origin: center center;
            will-change: transform, opacity;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-10vh) rotateZ(0deg) rotateY(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) rotateZ(720deg) rotateY(360deg);
                opacity: 0;
            }
        }

        /* Tablet Optimizations */
        @media (max-width: 1024px) {
            .container { max-width: 90%; padding: 15px; }
            h1 { font-size: calc(2.5rem + 2.2vw); }
            h2 { font-size: calc(1.8rem + 1.4vw); }
            p, li { font-size: calc(1.0rem + 0.35vw); line-height: 1.85; }
            .content-card { padding: 30px 35px; margin-bottom: 40px; }
        }

        @media (max-width: 768px) {
            h1 { font-size: calc(2.3rem + 2.8vw); }
            h2 { font-size: calc(1.6rem + 1.8vw); margin-bottom: 25px;}
            p, li { font-size: calc(0.95rem + 0.45vw); line-height: 1.8; margin-bottom: 18px;}
            .content-card { padding: 25px 30px; margin-bottom: 35px;}
            .burstiness-text p:nth-child(odd) { margin-left: 10px; padding-left: 8px; }
            .burstiness-text p:nth-child(even) { margin-right: 10px; padding-right: 8px; }
            .cta-button { padding: 14px 30px; font-size: 1em; }
        }
    </style>

    <!-- Import Map for Three.js Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
                "three/geometries/":"https://app.unpkg.com/three@0.163.0/files/examples/jsm/geometries"
            }
        }
    </script>

</head>
<body>

    <!-- Three.js Canvas Container -->
    <canvas id="three-canvas"></canvas>

    <!-- Confetti Container (Now styled with CSS) -->
    <div id="confetti-container"></div>

    <!-- HTML Content Overlay -->
    <div class="content-overlay">
        <div class="container">

            <!-- ç”Ÿæ—¥ç¥ç¦å¤´éƒ¨ -->
            <header class="content-card hero" id="top">
                <h1>Isaureï¼</h1>
                <p style="text-align: center; font-size: 1.3em; color: var(--secondary-color); text-shadow: 0 0 10px var(--secondary-color);">ä»Šå¤©ï¼Œå®‡å®™ä¸ºä½ ç‰¹åˆ«è°ƒäº®äº†æ˜Ÿè¾°ï¼âœ¨</p>
                <p style="text-align: center; font-style: italic; font-size: 1.1em;">è¿™ç»éæ—¥å†ä¸Šåº¸å¸¸çš„ä¸€é¡µç¿»è¿‡ï¼Œ<br>è¿™æ˜¯ç‹¬å±äºä½ çš„ï¼Œç››æ”¾çš„ï¼Œ<span class="highlight">å…‰èŠ’å››å°„</span>çš„æ—¶åˆ»ï¼</p>
                <h3 style="text-align: center; color: var(--accent-color); margin-top: 20px; animation: pulse 2s infinite;">ç”Ÿæ—¥å¿«ä¹ï¼ŒDear Isaure</h3>
            </header>

            <!-- å…³äºå¥¹çš„å…‰èŠ’ -->
            <section class="content-card about-her burstiness-text">
                <h2><span class="icon">â˜€ï¸</span>å…³äºä½ çš„å…‰èŠ’ä¸æ–‘æ–“</h2>
                <p>ä½ çš„ç¬‘é¥ï¼Œæ°ä¼¼ç››å¤ç ´æ™“æ—¶é‚£ç¬¬ä¸€ç¼•æœ€æ— é®æ‹¦çš„é˜³å…‰ï¼Œæ€»èƒ½è½»æ˜“åœ°èåŒ–ç§¯é›ªï¼Œé©±æ•£é˜´éœ¾ï¼Œæ˜åªšå¾—å«äººå¿ƒç”Ÿæš–æ„ï¼Œä¸–ç•Œä¸ºä¹‹ä¸€äº®ã€‚å¤–å‘ï¼Ÿå¼€æœ—ï¼Ÿè¿™äº›è¯è¯­å›ºç„¶æ•æ‰äº†ä½ çš„éƒ¨åˆ†å‰ªå½±ï¼Œå´åˆæ€èƒ½ç©·å°½ä½ çµé­‚æ·±å¤„é‚£è‚¡å¥”æ¶Œä¸æ¯ã€è¿‘ä¹é‡æ€§çš„ç”Ÿå‘½çƒ­åŠ›ï¼ä½ ï¼Œå°±åƒä¸€é¢—è•´è—ç€å®‡å®™æ´ªè’èƒ½é‡çš„æ˜Ÿæ ¸ï¼Œæ—¶åˆ»å‡†å¤‡ç€ï¼Œè¦çˆ†å‘å‡ºæœ€ä¸å¯æ€è®®çš„ç»šçƒ‚åå½©ã€‚</p>
                <p>æˆ‘çŸ¥é“ï¼Œè¿™ä¸–ç•Œå¹¶éæ€»æ˜¯é“ºæ»¡ç«ç‘°ä¸ä¸ç»’ï¼Œè¿™ä¸ªä¸–ç•Œå¸¦æ¥çš„é˜´å½±æˆ–è®¸æ›¾è®©ä½ æ­¥å±¥è¹’è·šï¼Œç•™ä¸‹éš¾ä»¥è¨€è¯´çš„åˆ»ç—•ã€‚ä½†è¯·ä½ çœ‹çœ‹è‡ªå·±â€”â€”çœ‹å•Šï¼é‚£äº›è¿‡å¾€çš„é£éœœï¼Œæˆ–è®¸æ›¾ç»æ‰“è´¥äº†ä½  ä½†æˆ‘æ¥äº†</p>
                <p>è€Œå½“ä½ å…¨ç„¶æ²‰æµ¸äºæŒšçˆ±ä¹‹äº‹â€”â€”<span class="icon">ğŸ¤</span>æ”¾å£°æ­Œå”±æ—¶ï¼Œé‚£æ­Œå£°ï¼Œæ—¶è€Œæ˜¯ç©¿é€äº‘éœ­çš„æ¸…å†½å±±æ³‰ï¼Œæµæ·Œç€æŠšæ…°äººå¿ƒçš„æ¸©æŸ”ï¼›æ—¶è€Œæ˜¯æ€èµ·é£æš´çš„æµ·æ½®ï¼Œè•´å«ç€éœ‡æ’¼çµé­‚çš„åŠ›é‡ï¼Œæ¯ä¸€ä¸ªéŸ³ç¬¦éƒ½ä»¿ä½›è¢«èµ‹äºˆäº†ç”Ÿå‘½ï¼Œåœ¨ç©ºæ°”ä¸­èˆè¹ˆã€å›æ—‹ã€‚<span class="icon">ğŸ¨</span>æŒ¥åŠ¨ç”»ç¬”æ—¶ï¼Œä½ çš„æŒ‡å°–ä¾¿æ‹¥æœ‰äº†ç‚¹çŸ³æˆé‡‘çš„é­”æ³•ï¼Œè‰²å½©åœ¨ä½ æ‰‹ä¸­ä¸å†ä»…ä»…æ˜¯é¢œæ–™ï¼Œå®ƒä»¬æ˜¯æƒ…ç»ªçš„è½½ä½“ï¼Œæ˜¯æ¢¦æƒ³çš„ç¢ç‰‡ï¼Œæ˜¯ä½ åœ¨ç”»å¸ƒä¸Šæ„å»ºçš„ä¸€ä¸ªåˆä¸€ä¸ªå¹³è¡Œå®‡å®™ï¼Œé‚£é‡Œå…‰é£éœæœˆï¼Œé¸Ÿè¯­èŠ±é¦™ï¼Œæ˜¯ä½ å†…å¿ƒæ·±å¤„ä¸ç­çš„ç†æƒ³å›½ã€‚</p>
                <p>ä½ çš„æ‰åï¼Œä¸æ˜¯å­¤èŠ³è‡ªèµçš„æ°´ä»™ï¼Œè€Œæ˜¯é»‘å¤œä¸­æŒ‡å¼•èˆªèˆ¹çš„ç¯å¡”ï¼Œæ—¢ç…§äº®äº†è‡ªå·±å‰è¡Œçš„è·¯ï¼Œä¹Ÿæ¸©æš–äº†æ‰€æœ‰é è¿‘ä½ çš„äººã€‚</p>
            </section>

            <!-- æˆ‘ä»¬çš„å‹è°Š -->
            <section class="content-card friendship burstiness-text">
                <h2><span class="icon">ğŸ’–</span>æˆ‘ä»¬ä¹‹é—´ï¼Œæ˜¯è¶…è¶Šå®šä¹‰çš„ç¾ç»Š</h2>
                <p>æˆ‘ä»¬æ›¾å¹¶è‚©ä½œæˆ˜ã€æŠµå¾¡é£æµªçš„åŒè¢ï¼Œé‚£äº›ä¸€èµ·ç†¬è¿‡çš„å¤œï¼Œä¸€èµ·æ”»å…‹çš„éš¾å…³ï¼Œéƒ½å·²åŒ–ä½œå½¼æ­¤å¿ƒä¸­æ— éœ€è¨€è¯´çš„é»˜å¥‘ï¼›æˆ‘ä»¬æ›´æ˜¯äº¤æ¢å¿ƒäº‹ã€åˆ†äº«è„†å¼±çš„çŸ¥å·±ï¼Œé‚£äº›æ·±å¤œæœˆå…‰ä¸‹çš„çªƒçªƒç§è¯­ï¼Œé‚£äº›åªæœ‰æˆ‘ä»¬æ‰æ‡‚çš„æ¢—å’Œç¬é—´ï¼Œæ—©å·²æˆä¸ºçµé­‚æ·±å¤„æœ€æ¸©æš–çš„ç§˜è—ã€‚çŸ¥é“å—ï¼Ÿæ— è®ºé¡ºå¢ƒé€†æ—…ï¼Œæ€»æœ‰ä¸€ä¸ªè§’è½ä¸ºä½ ç•™ç€ï¼Œæ€»æœ‰ä¸€ä¸ªå£°éŸ³å¯¹ä½ è¯´ï¼š"æˆ‘æ°¸è¿œæ‡‚ä½  æŠ±æŠ±"</p>
                <p>æ˜¯ä½ ï¼Œæ•™ä¼šæˆ‘é‡Šæ”¾å‹åŠ›ï¼›ä¹Ÿæ˜¯ä½ ï¼Œè®©æˆ‘æ·±åˆ»ä½“ä¼šåˆ°ï¼Œå³ä¾¿èº«å¤„å¹½è°·ï¼Œä¹Ÿè¦æ°¸è¿œå‘ç€é˜³å…‰çš„æ–¹å‘ï¼Œå€”å¼ºç”Ÿé•¿ã€‚ä½ åœ¨æˆ‘ç»æœ›çš„æ—¶å€™ä»æ·±æ¸Šä¸­æŠŠæˆ‘æ‹‰èµ·ï¼Œç”šè‡³ä¸æƒœè‡ªå·±ã€‚è¿™ä»½å‹è°Šï¼Œå®ƒåšéŸ§è¿‡æœ€ç¡¬çš„é’»çŸ³ï¼Œæ¸©æš–è¿‡å†¬æ—¥çš„ç‚‰ç«ï¼Œçº¯ç²¹è¿‡åˆç”Ÿçš„æœéœ²â€”â€”èƒ½é‡è§ä½ ï¼Œæ˜¯æˆ‘æ­¤ç”Ÿä½•å…¶å¹¸é‹çš„æ©å…¸ã€‚çœŸçš„ï¼Œåƒè¨€ä¸‡è¯­ï¼Œæ±‡æˆä¸€å¥ï¼šè°¢è°¢ä½ ï¼Œå‡ºç°åœ¨æˆ‘çš„ç”Ÿå‘½é‡Œï¼</p>
                <p>è¿™ä»½æƒ…è°Šï¼Œæ—©å·²è¶…è¶Š"å‹è°Š"äºŒå­—çš„ç®€å•ç•Œå®šï¼Œå®ƒæ˜¯ä¸€ç§æ·±åˆ»ã€å¤æ‚çš„çš„è¿æ¥ï¼Œä¸€ç§çµé­‚çš„å›å“ï¼Œåœ¨å²æœˆçš„é•¿æ²³é‡Œç† ç† ç”Ÿè¾‰ï¼Œå†ä¹…å¼¥åšã€‚</p>
            </section>

            <!-- æ¸©æŸ”çš„é¼“åŠ±ä¸ç¥ç¦ -->
            <section class="content-card wishes burstiness-text">
                <h2><span class="icon">ğŸŒŸ</span>æ„¿ä½ çš„ä¸–ç•Œï¼Œä»æ­¤æ™´ç©ºä¸‡é‡Œï¼Œç¹èŠ±ä¼¼é”¦</h2>
                <p>Dear Isaureï¼Œæˆ‘çŸ¥é“çš„ï¼Œç”Ÿæ´»è¿™æœ¬åšé‡çš„ä¹¦ï¼Œå¹¶éæ¯ä¸€é¡µéƒ½å†™æ»¡äº†è¯—æƒ…ç”»æ„ã€‚é‚£äº›ä¸æœŸè€Œè‡³çš„é£é›¨ï¼Œé‚£äº›æ²‰ç”¸ç”¸å‹åœ¨å¿ƒå¤´çš„å¾€äº‹ï¼Œæˆ–è®¸è®©ä½ æ„Ÿåˆ°ç–²æƒ«ï¼Œç”šè‡³å¶æœ‰ç¬é—´çš„é»¯æ·¡ã€‚ä½†è¯·ä½ åŠ¡å¿…åšä¿¡â€”â€”ä½ å†…åœ¨è•´è—çš„é‚£æŸå…‰ï¼Œé‚£ç‹¬ä¸€æ— äºŒçš„çµé­‚ç«ç„°ï¼Œä»æœªæœ‰ç†„ç­ï¼å³ä¾¿ä»–ä¼¼ä¹å¿«è¦ç†„ç­äº†ï¼Œæˆ‘å“ªæ€•å°†è‡ªå·±ä½œä¸ºé‚£äº›è±†èï¼Œä¹Ÿè¦å°†ä½ æ¨å‘ç¾å¥½çš„æœªæ¥ã€‚</p>
                <p>è¿‡å»çš„ä¼¤ç—•ï¼Œå®ƒä»¬å¡‘é€ äº†ä½ çš„ä¸€éƒ¨åˆ†ï¼Œå´ç»ä¸èƒ½å®šä¹‰ä½ çš„å…¨éƒ¨ï¼ä½ é‚£é¢—å¼ºå¤§è€Œæ¸©æŸ”çš„å¿ƒï¼Œä½ å¯¹è‰ºæœ¯ä¸ç¾çš„æ‰§ç€çƒ­çˆ±ï¼Œä½ åˆ›é€ å¿«ä¹ã€æ„ŸæŸ“ä»–äººçš„éå‡¡èƒ½åŠ›â€”â€”è¿™ï¼Œè¿™æ‰æ˜¯ä½ æœ€çœŸå®ã€æœ€å®è´µçš„å†…æ ¸ï¼æ˜¯é‚£ä¸ªå”±æ­Œæ—¶çœ¼é‡Œæœ‰æ˜Ÿæ²³ç’€ç’¨ï¼Œç”»ç”»æ—¶æŒ‡å°–æœ‰è¶èˆç¿©è·¹çš„ä½ ï¼ä¸è¦ï¼Œæ°¸è¿œä¸è¦è®©ä»»ä½•é˜´éœ¾é®è”½äº†ä½ çœºæœ›è¿œæ–¹çš„è§†çº¿ã€‚ä½ çœ‹ï¼Œå‰æ–¹æ˜¯å¤šä¹ˆè¾½é˜”æ— å çš„å¤©åœ°ï¼Œæ­£ç­‰å¾…ä½ ç”¨æœ€å˜¹äº®çš„æ­Œå£°å»å›åº”ï¼Œç”¨æœ€ç»šçƒ‚çš„è‰²å½©å»æç»˜ï¼å»æ‹¥æŠ±ï¼å»å¾æœï¼</p>
                <p>æ‰€ä»¥ï¼Œä»Šå¤©ï¼Œè¿™ä¸ªç‰¹æ®Šçš„æ—¥å­ï¼Œä»¥åŠæœªæ¥æ¯ä¸€ä¸ªå€¼å¾—åº†ç¥çš„å¹³å‡¡ç¬é—´ï¼Œè¯·ä½ <span class="highlight">æ— æ‰€é¡¾å¿Œåœ°æ”¾å£°æ­Œå”±å§ï¼æ·‹æ¼“å°½è‡´åœ°æŒ¥æ´’ä½ çš„è‰²å½©å§ï¼</span>å»åšä¸€åˆ‡èƒ½ç‚¹ç‡ƒä½ çƒ­æƒ…ã€è®©ä½ å¿ƒè·³æ¼æ‰åŠæ‹ã€è®©ä½ å˜´è§’ä¸è‡ªè§‰ä¸Šæ‰¬çš„äº‹æƒ…ï¼å‹‡æ•¢å»çˆ±ï¼Œçƒ­çƒˆå»æ„Ÿå—ï¼Œå¤§èƒ†å»åˆ›é€ ï¼Œä¹¦å†™åªå±äºä½ çš„ã€ç‹¬ä¸€æ— äºŒçš„ç”Ÿå‘½ä¼ å¥‡ï¼</p>
                <p>æ„¿å¿«ä¹ä»æ­¤æˆä¸ºä½ çš„æ—¥å¸¸æ ‡é…ï¼Œåƒç©ºæ°”ä¸€æ ·æ— å¤„ä¸åœ¨ï¼›æ„¿æ¸©æš–æ—¶åˆ»å°†ä½ ç´§ç´§ç¯ç»•ï¼Œå¦‚åŒæœ€è´´èº«çš„æ‹¥æŠ±ï¼›æ„¿ä¸–é—´æ‰€æœ‰ä¸æœŸè€Œé‡çš„ç¾å¥½ï¼Œéƒ½äº‰å…ˆæååœ°å‘ä½ å¥”æ¶Œè€Œæ¥ï¼Œæ±‡èšæˆå¹¸ç¦çš„æµ·æ´‹ï¼æ„¿ä½ çš„æ¯ä¸€å¤©ï¼Œéƒ½å……æ»¡æ„æƒ³ä¸åˆ°çš„æƒŠå–œä¸ä¸å®¹ç½®ç–‘çš„å¥½è¿ï¼<br>ç”Ÿæ—¥å¿«ä¹ï¼Œæˆ‘å¿ƒä¸­æ— å¯æ›¿ä»£çš„Isaureï¼<br>æ„¿ä½ çš„ä¸–ç•Œï¼Œè‡ªæ­¤åªæœ‰æ–‘æ–“è‰²å½©ï¼Œå†æ— ä¸€ä¸é˜´éœ¾ï¼</p>
                <div style="text-align: center;">
                    <a href="#top" class="cta-button" onclick="document.getElementById('top').scrollIntoView({ behavior: 'smooth' }); return false;">å›åˆ°æ˜Ÿå…‰ä¹‹å·…ï¼</a>
                </div>
            </section>

            <!-- é¡µè„š -->
             <footer>
                ç”¨æ¼«å¤©æ˜Ÿè¾°ä½œå¢¨ï¼Œå†™ä¸‹è¿™ä»½ç¥ç¦ï¼Œ<br>
                é€ç»™ç‹¬ä¸€æ— äºŒçš„ä½ ï¼Œæˆ‘æœ€å¥½çš„æœ‹å‹ã€‚
            </footer>
             <p style="font-size: 0.65em; /* è°ƒæ•´ä¸ºä½ æƒ³è¦çš„ç²¾ç¡®å¤§å° */
                      color: rgba(255, 255, 255, 0.7); /* ç™½è‰²å¸¦ä¸€ç‚¹é€æ˜ */
                      text-align: center;
                      margin-top: 20px; /* ä¸é¡µè„šçš„è·ç¦» */
                      padding-bottom: 15px; /* è·ç¦»é¡µé¢åº•éƒ¨çš„è·ç¦» */
                      opacity: 0.8; /* è½»å¾®é€æ˜ */
                      letter-spacing: 0.5px; /* è½»å¾®å¢åŠ å­—é—´è· */
                      position: relative; /* ç¡®ä¿åœ¨canvasä¹‹ä¸Š */
                      z-index: 2;">
                æœ€å You're the only one I want to give the most affection to.
            </p>
        </div>
    </div>

    <!-- Embedded Three.js Script (Module Type) -->
    <script type="module">
        import * as THREE from 'three'; // Imports the core library
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/geometries/TextGeometry.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
        // No need for the 'three/src/' imports here
        // Scene Setup
        const scene = new THREE.Scene();
        const canvas = document.getElementById('three-canvas');
        let renderer, composer, bloomPass;
        let textMesh = null;
        // Use THREE.TextureLoader because TextureLoader is part of the core THREE object
        const textureLoader = new THREE.TextureLoader();


        try {
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.25; // Slightly increased exposure for vibrancy
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        } catch (error) {
            console.error("WebGL is not supported or renderer initialization failed:", error);
            // Fallback message display logic (same as before)
            const overlay = document.querySelector('.content-overlay');
            if (overlay) overlay.style.display = 'none';
            document.body.innerHTML = "<div style='color:white; text-align:center; padding: 50px; font-size: 1.2em; font-family: sans-serif;'>æŠ±æ­‰ï¼Œæ‚¨çš„è®¾å¤‡ä¼¼ä¹ä¸æ”¯æŒåˆ›å»ºè¿™ä¸ª3Dæ•ˆæœæ‰€éœ€çš„æŠ€æœ¯(WebGL)ã€‚<br>ä½†è¿™ä»½ç”Ÿæ—¥ç¥ç¦çš„å¿ƒæ„ä¸å˜ï¼ç”Ÿæ—¥å¿«ä¹ï¼ŒIsaureï¼</div>" + (overlay ? overlay.outerHTML : '');
            if(canvas) canvas.style.display = 'none';
            throw new Error("Renderer failed to initialize.");
        }

        // Camera
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 3000); // Increased far plane for nebula
        camera.position.set(0, 20, 85); // Adjusted camera start

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.04;
        controls.enableZoom = true;
        controls.zoomSpeed = 0.6;
        controls.enablePan = false;
        controls.minDistance = 30;
        controls.maxDistance = 250; // Allow zooming out further
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.35; // Slightly slower auto-rotate
        controls.maxPolarAngle = Math.PI * 0.88;
        controls.minPolarAngle = Math.PI * 0.12;

        // --- Enhanced Lighting & Lens Flares ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.65); // Slightly brighter ambient
        scene.add(ambientLight);

        // --- Placeholder Textures - REPLACE THESE URLS! ---
        const texFlare1 = textureLoader.load( '/path/to/lensflare0.png' ); // Circle glow
        const texFlare2 = textureLoader.load( '/path/to/lensflare2.png' ); // Generic flare
        const texFlare3 = textureLoader.load( '/path/to/lensflare3.png' ); // Hexagonal flare

        // Pink Light + Flare
        const pointLight1 = new THREE.PointLight(0xff69b4, 500, 400, 1.7); // Adjusted params
        pointLight1.position.set(90, 70, 90);
        pointLight1.castShadow = true;
        pointLight1.shadow.mapSize.width = 1024;
        pointLight1.shadow.mapSize.height = 1024;
        pointLight1.shadow.camera.near = 10;
        pointLight1.shadow.camera.far = 450;
        pointLight1.shadow.bias = -0.002; // Fine-tune bias
        scene.add(pointLight1);
        addLensflare(pointLight1, 0.6, texFlare1, texFlare3); // Add flare to this light

        // Plum Light + Flare
        const pointLight2 = new THREE.PointLight(0xdda0dd, 400, 350, 1.8);
        pointLight2.position.set(-90, -70, 70);
        // pointLight2.castShadow = true; // Optional shadows
        scene.add(pointLight2);
        addLensflare(pointLight2, 0.4, texFlare1, texFlare3); // Add flare

        // Gold Light + Flare
        const pointLight3 = new THREE.PointLight(0xffd700, 350, 350, 1.8);
        pointLight3.position.set(0, -80, 140);
        // pointLight3.castShadow = true; // Optional shadows
        scene.add(pointLight3);
        addLensflare(pointLight3, 0.5, texFlare1, texFlare2); // Add flare

        // Helper function to add lens flares
        function addLensflare(light, scale, tex1, tex2) {
            const lensflare = new Lensflare();
            // Main glow
            lensflare.addElement( new LensflareElement( tex1, 512 * scale, 0, light.color.clone().multiplyScalar(0.8) ) );
            // Smaller hexagonal elements
            lensflare.addElement( new LensflareElement( tex2, 60 * scale, 0.6 ) );
            lensflare.addElement( new LensflareElement( tex2, 70 * scale, 0.7 ) );
            lensflare.addElement( new LensflareElement( tex2, 120 * scale, 0.9 ) );
            lensflare.addElement( new LensflareElement( tex2, 70 * scale, 1 ) );
            light.add( lensflare ); // Attach flare to the light source
        }

        // Light Halos (same as before)
        const lightHalo1 = createLightHalo(0xff69b4, 20); lightHalo1.position.copy(pointLight1.position); scene.add(lightHalo1);
        const lightHalo2 = createLightHalo(0xdda0dd, 17); lightHalo2.position.copy(pointLight2.position); scene.add(lightHalo2);
        const lightHalo3 = createLightHalo(0xffd700, 15); lightHalo3.position.copy(pointLight3.position); scene.add(lightHalo3);
        function createLightHalo(color, size) { /* ... (same function as before) ... */
            const geometry = new THREE.SphereGeometry(size, 32, 16);
            const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false });
            return new THREE.Mesh(geometry, material);
        }


        // Post-processing (Bloom)
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.45, 0.6, 0.65); // Adjusted bloom params
        composer.addPass(bloomPass);


        // --- NEW: Nebula Background ---
        const nebulaTexture = textureLoader.load('/path/to/nebula.jpg'); // <<< REPLACE URL!
        nebulaTexture.wrapS = THREE.RepeatWrapping; // Optional: Tiling if needed
        nebulaTexture.wrapT = THREE.RepeatWrapping;
        const nebulaMaterial = new THREE.MeshBasicMaterial({
            map: nebulaTexture,
            side: THREE.BackSide, // Render on the inside of the sphere
            fog: false // Ignore scene fog
        });
        const nebulaGeometry = new THREE.SphereGeometry(1500, 64, 32); // Large sphere
        const nebulaMesh = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
        nebulaMesh.rotation.y = Math.PI / 4; // Initial rotation
        scene.add(nebulaMesh);


        // Particle System 1: Galaxy (same core logic, adjusted params)
        const particleCount1 = 20000; // More particles
        const particlesGeometry1 = new THREE.BufferGeometry();
        // ... (Arrays: posArray1, colorArray1, sizeArray1) ...
        const posArray1 = new Float32Array(particleCount1 * 3);
        const colorArray1 = new Float32Array(particleCount1 * 3);
        const sizeArray1 = new Float32Array(particleCount1);
        const colorPalette = [ /* ... (same colors) ... */
            new THREE.Color(0xff69b4), new THREE.Color(0xdda0dd), new THREE.Color(0xffd700),
            new THREE.Color(0x9370db), new THREE.Color(0xffffff)
        ];
        for(let i = 0; i < particleCount1; i++) {
            const i3 = i * 3;
            const radius = 180 + Math.random() * 600; // Wider spread
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray1[i3] = radius * Math.sin(phi) * Math.cos(theta);
            posArray1[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            posArray1[i3 + 2] = radius * Math.cos(phi);
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            const finalColor = Math.random() < 0.3 ? (Math.random() < 0.5 ? colorPalette[4] : colorPalette[2]) : color;
            colorArray1[i3] = finalColor.r; colorArray1[i3 + 1] = finalColor.g; colorArray1[i3 + 2] = finalColor.b;
            sizeArray1[i] = Math.random() * 3.2 + 0.9; // Slightly larger range
        }
        particlesGeometry1.setAttribute('position', new THREE.BufferAttribute(posArray1, 3));
        particlesGeometry1.setAttribute('color', new THREE.BufferAttribute(colorArray1, 3));
        particlesGeometry1.setAttribute('size', new THREE.BufferAttribute(sizeArray1, 1));
        const particleMaterial1 = new THREE.PointsMaterial({ /* ... (same material setup) ... */
            vertexColors: true, transparent: true, blending: THREE.AdditiveBlending,
            sizeAttenuation: true, map: createSparkleTexture(), depthWrite: false, alphaTest: 0.01
        });
        const particleSystem1 = new THREE.Points(particlesGeometry1, particleMaterial1);
        scene.add(particleSystem1);


        // --- NEW: Particle System 2 (Ambient Dust/Sparkles) ---
        const particleCount2 = 15000;
        const particlesGeometry2 = new THREE.BufferGeometry();
        const posArray2 = new Float32Array(particleCount2 * 3);
        const colorArray2 = new Float32Array(particleCount2 * 3);
        const sizeArray2 = new Float32Array(particleCount2);
        const dustColor1 = new THREE.Color(0xffffff);
        const dustColor2 = new THREE.Color(0xffeecc); // Warm white

        for(let i = 0; i < particleCount2; i++) {
            const i3 = i * 3;
            // Closer, denser distribution
            const radius = 20 + Math.random() * 150; // Range: 20 to 170
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray2[i3] = radius * Math.sin(phi) * Math.cos(theta);
            posArray2[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            posArray2[i3 + 2] = radius * Math.cos(phi);
            // Mostly white/pale colors
            const color = Math.random() > 0.5 ? dustColor1 : dustColor2;
            colorArray2[i3] = color.r; colorArray2[i3 + 1] = color.g; colorArray2[i3 + 2] = color.b;
            // Smaller sizes
            sizeArray2[i] = Math.random() * 1.5 + 0.3; // Range: 0.3 to 1.8
        }
        particlesGeometry2.setAttribute('position', new THREE.BufferAttribute(posArray2, 3));
        particlesGeometry2.setAttribute('color', new THREE.BufferAttribute(colorArray2, 3));
        particlesGeometry2.setAttribute('size', new THREE.BufferAttribute(sizeArray2, 1));
        const particleMaterial2 = new THREE.PointsMaterial({
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
            map: createSparkleTexture(), // Can use the same texture or a different one
            depthWrite: false,
            alphaTest: 0.01,
            opacity: 0.7 // Slightly less opaque
        });
        const particleSystem2 = new THREE.Points(particlesGeometry2, particleMaterial2);
        scene.add(particleSystem2);


        // Sparkle Texture Function (same as before)
        function createSparkleTexture() { /* ... (same function as before) ... */
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d'); if (!context) return null;
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); gradient.addColorStop(0.15, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.3)'); gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient; context.fillRect(0, 0, 128, 128);
            const texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture;
        }

        // Floating 3D Text (same as before)
        const textLoader = new FontLoader();
        textLoader.load('https://unpkg.com/three@0.163.0/examples/fonts/helvetiker_regular.typeface.json', font => {
            const textGeometry = new TextGeometry('Happy Birthday', { /* ... (same settings) ... */
                 font: font, size: 8, height: 1.5, curveSegments: 16,
                 bevelEnabled: true, bevelThickness: 0.6, bevelSize: 0.3, bevelOffset: 0, bevelSegments: 8
            });
            textGeometry.center();
            const textMaterial = new THREE.MeshStandardMaterial({ /* ... (same material) ... */
                color: 0xff69b4, emissive: 0xdda0dd, emissiveIntensity: 0.35, // Slightly brighter emissive
                metalness: 0.4, roughness: 0.5, flatShading: false
            });
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(0, 5, -15); // Adjusted position
            textMesh.castShadow = true;
            scene.add(textMesh);
        }, xhr => console.log((xhr.loaded / xhr.total * 100) + '% font loaded'), err => console.error('Font loading error:', err));


        // Floating Shapes (same logic, more shapes)
        const shapesGroup = new THREE.Group();
        const shapeGeometries = [ /* ... (same geometries) ... */
             new THREE.IcosahedronGeometry(3.5, 1), new THREE.TorusKnotGeometry(2.5, 0.8, 128, 16),
             new THREE.OctahedronGeometry(3, 1), new THREE.DodecahedronGeometry(3.2, 0),
             new THREE.TorusGeometry(2.8, 1, 20, 60)
        ];
        const shapesCount = 55; // Increased count
        for(let i = 0; i < shapesCount; i++) {
             const geometry = shapeGeometries[i % shapeGeometries.length];
             const material = new THREE.MeshStandardMaterial({ /* ... (same material setup) ... */
                color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                metalness: Math.random() * 0.7, roughness: Math.random() * 0.6 + 0.2,
                transparent: true, opacity: 0.9 + Math.random() * 0.1,
             });
            const shape = new THREE.Mesh(geometry, material);
            const radius = 70 + Math.random() * 120; // Adjusted distribution range
            const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
            shape.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
            shape.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            shape.castShadow = true;
            shape.userData = { /* ... (same animation data structure) ... */
                orbitSpeed: (Math.random() - 0.5) * 0.012, rotationSpeed: (Math.random() - 0.5) * 0.03,
                bobSpeed: Math.random() * 0.9 + 0.5, amplitude: Math.random() * 5 + 2,
                initialY: shape.position.y
            };
            shapesGroup.add(shape);
        }
        scene.add(shapesGroup);


        // --- NEW: Floating Stars ---
        const starsGroup = new THREE.Group();
        const starShape = new THREE.Shape();
        const outerRadius = 2.5;
        const innerRadius = 1.2;
        const numPoints = 5;
        starShape.moveTo(0, outerRadius);
        for (let i = 0; i < numPoints * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i / (numPoints * 2)) * Math.PI * 2;
            starShape.lineTo(Math.sin(angle) * radius, Math.cos(angle) * radius);
        }
        const extrudeSettings = { depth: 0.5, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.1, bevelThickness: 0.1 };
        const starGeometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
        starGeometry.center(); // Center the geometry

        const starMaterials = [
            new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.6, roughness: 0.4, emissive: 0xccaa00, emissiveIntensity: 0.3 }), // Gold
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.5, roughness: 0.5, emissive: 0xaaaaaa, emissiveIntensity: 0.2 }), // Silver/White
            new THREE.MeshStandardMaterial({ color: 0xffacdf, metalness: 0.5, roughness: 0.5, emissive: 0xcc8aad, emissiveIntensity: 0.25 }) // Pinkish
        ];
        const starCount = 40;

        for (let i = 0; i < starCount; i++) {
            const material = starMaterials[i % starMaterials.length];
            const star = new THREE.Mesh(starGeometry, material);
            const radius = 50 + Math.random() * 150; // Similar distribution to shapes
            const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
            star.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
            star.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            star.scale.setScalar(Math.random() * 0.8 + 0.6); // Random size
            star.castShadow = true;
            star.userData = { // Similar animation data
                orbitSpeed: (Math.random() - 0.5) * 0.010, rotationSpeed: (Math.random() - 0.5) * 0.035,
                bobSpeed: Math.random() * 1.0 + 0.4, amplitude: Math.random() * 4 + 1.5,
                initialY: star.position.y
            };
            starsGroup.add(star);
        }
        scene.add(starsGroup);


        // --- NEW: Spiral Ribbons ---
        const ribbonsGroup = new THREE.Group();
        const ribbonColors = [0xff69b4, 0xdda0dd, 0xffd700, 0x87cefa, 0xffffff];
        const numRibbons = 8;
        const ribbonSegments = 150;
        const ribbonRadius = 1.0; // Thickness of the ribbon tube

        for (let i = 0; i < numRibbons; i++) {
            const points = [];
            const startRadius = 10 + Math.random() * 10;
            const endRadius = 80 + Math.random() * 50;
            const spirals = 3 + Math.random() * 4;
            const height = 100 + Math.random() * 60;
            const startY = (Math.random() - 0.5) * 40;
            const phase = Math.random() * Math.PI * 2;

            for (let j = 0; j <= ribbonSegments; j++) {
                const t = j / ribbonSegments; // Parameter 0 to 1
                const radius = startRadius + (endRadius - startRadius) * t;
                const angle = phase + t * Math.PI * 2 * spirals;
                const y = startY + (height * (t - 0.5)); // Goes up and down
                points.push(new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(curve, ribbonSegments, ribbonRadius, 12, false); // 12 radial segments
            const material = new THREE.MeshStandardMaterial({
                color: ribbonColors[i % ribbonColors.length],
                metalness: 0.3,
                roughness: 0.6,
                side: THREE.DoubleSide // Render both sides
            });
            const ribbon = new THREE.Mesh(geometry, material);
            ribbon.castShadow = true;
            ribbonsGroup.add(ribbon);
        }
        ribbonsGroup.rotation.x = 0.2; // Slight tilt
        scene.add(ribbonsGroup);


        // Floating Balloons (same logic, more balloons)
        const balloonsGroup = new THREE.Group();
        const balloonCount = 40; // Increased count
        const balloonColors = [ /* ... (same colors + more) ... */
            0xff69b4, 0xdda0dd, 0xffd700, 0x87cefa, 0x98fb98, 0xffa07a, 0xa0e0e0, 0xffc0cb
        ];
        const balloonSpawnArea = 200; // Wider spawn
        const balloonMaxHeight = 300; const balloonMinHeight = -200;
        function createBalloons() {
            const balloonGeometry = new THREE.SphereGeometry(3.0, 32, 24); // Slightly larger
            balloonGeometry.scale(1, 1.2, 1);
            for (let i = 0; i < balloonCount; i++) {
                 const balloonMaterial = new THREE.MeshStandardMaterial({ /* ... (same material setup) ... */
                    color: balloonColors[Math.floor(Math.random() * balloonColors.length)],
                    metalness: 0.05, roughness: 0.7, transparent: true, opacity: 0.92,
                 });
                const balloon = new THREE.Mesh(balloonGeometry, balloonMaterial);
                balloon.position.x = (Math.random() - 0.5) * balloonSpawnArea;
                balloon.position.z = (Math.random() - 0.5) * balloonSpawnArea;
                balloon.position.y = balloonMinHeight + Math.random() * 140;
                balloon.castShadow = true;
                balloon.userData = { /* ... (same animation data structure) ... */
                    baseYSpeed: Math.random() * 0.1 + 0.07, driftSpeedX: Math.random() * 0.6 + 0.3,
                    driftSpeedZ: Math.random() * 0.6 + 0.3, driftAmplitudeX: Math.random() * 0.07 + 0.03,
                    driftAmplitudeZ: Math.random() * 0.07 + 0.03, initialPhaseX: Math.random() * Math.PI * 2,
                    initialPhaseZ: Math.random() * Math.PI * 2
                };
                balloonsGroup.add(balloon);
            }
            scene.add(balloonsGroup);
        }


        // Animation loop
        const clock = new THREE.Clock();
        const rotationAxis = new THREE.Vector3(0, 1, 0);

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();

            // Animate Nebula Background (Slow rotation)
            nebulaMesh.rotation.y += deltaTime * 0.005;

            // Animate Particle System 1 (Galaxy)
            particleSystem1.rotation.y = elapsedTime * 0.008; // Slower
            particleSystem1.rotation.x = elapsedTime * 0.004;

            // Animate Particle System 2 (Dust)
            particleSystem2.rotation.y = -elapsedTime * 0.015; // Opposite, slightly faster rotation
            particleSystem2.rotation.z = elapsedTime * 0.006;

            // Animate Shapes (Orbit, Rotate, Bob)
            shapesGroup.children.forEach(shape => { /* ... (same animation logic) ... */
                 const { orbitSpeed, rotationSpeed, bobSpeed, amplitude, initialY } = shape.userData;
                 shape.position.applyAxisAngle(rotationAxis, orbitSpeed * deltaTime);
                 shape.position.y = initialY + Math.sin(elapsedTime * bobSpeed + shape.id) * amplitude;
                 shape.rotation.x += rotationSpeed * deltaTime; shape.rotation.y += rotationSpeed * 0.7 * deltaTime; shape.rotation.z += rotationSpeed * 0.4 * deltaTime;
            });

            // Animate Stars (Orbit, Rotate, Bob)
            starsGroup.children.forEach(star => { /* ... (same animation logic as shapes) ... */
                 const { orbitSpeed, rotationSpeed, bobSpeed, amplitude, initialY } = star.userData;
                 star.position.applyAxisAngle(rotationAxis, orbitSpeed * deltaTime);
                 star.position.y = initialY + Math.sin(elapsedTime * bobSpeed + star.id * 1.1) * amplitude; // Use id for phase offset
                 star.rotation.x += rotationSpeed * 0.8 * deltaTime; star.rotation.y += rotationSpeed * deltaTime; star.rotation.z += rotationSpeed * 0.6 * deltaTime;
            });

            // Animate Ribbons (Slow rotation)
            ribbonsGroup.rotation.y += deltaTime * 0.02;
            ribbonsGroup.rotation.z = Math.sin(elapsedTime * 0.2) * 0.1; // Gentle sway

             // Animate Text
             if (textMesh) { /* ... (same animation logic) ... */
                 textMesh.rotation.y = Math.sin(elapsedTime * 0.35) * 0.18;
                 textMesh.position.y = 5 + Math.sin(elapsedTime * 0.55) * 1.8; // Adjusted base Y
             }

             // Animate Balloons
             balloonsGroup.children.forEach(balloon => { /* ... (same animation logic, check bounds) ... */
                 const ud = balloon.userData;
                 balloon.position.y += ud.baseYSpeed * deltaTime * 60;
                 const swayX = Math.sin(elapsedTime * ud.driftSpeedX + ud.initialPhaseX) * ud.driftAmplitudeX;
                 const swayZ = Math.cos(elapsedTime * ud.driftSpeedZ + ud.initialPhaseZ) * ud.driftAmplitudeZ;
                 balloon.position.x += swayX * deltaTime * 60;
                 balloon.position.z += swayZ * deltaTime * 60;
                 if (balloon.position.y > balloonMaxHeight) {
                     balloon.position.y = balloonMinHeight - Math.random() * 40; // Reset lower
                     balloon.position.x = (Math.random() - 0.5) * balloonSpawnArea;
                     balloon.position.z = (Math.random() - 0.5) * balloonSpawnArea;
                     ud.initialPhaseX = Math.random() * Math.PI * 2; ud.initialPhaseZ = Math.random() * Math.PI * 2;
                 }
             });

            controls.update(); // Update controls
            composer.render(); // Render via composer (includes bloom)
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        // CSS Confetti (same logic, maybe more confetti)
        function createConfetti() {
            const container = document.getElementById('confetti-container');
            if (!container) return;
            const colors = [ /* ... (same colors) ... */
                '#ff69b4', '#dda0dd', '#ffd700', '#9370db', '#ffffff', '#87cefa', '#98fb98', '#ffc0cb'
            ];
            const count = 250; // More confetti
            container.innerHTML = '';
            for(let i = 0; i < count; i++) { /* ... (same confetti element creation logic) ... */
                const confetti = document.createElement('div'); confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                const isRect = Math.random() > 0.4;
                confetti.style.width = Math.random() * (isRect ? 7 : 10) + 4 + 'px';
                confetti.style.height = Math.random() * (isRect ? 11 : 7) + 4 + 'px';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.opacity = Math.random() * 0.4 + 0.6;
                confetti.style.animationDuration = Math.random() * 5 + 4 + 's';
                confetti.style.animationDelay = Math.random() * 8 + 's'; // Slightly longer delay potential
                confetti.style.transform = `rotate(${Math.random() * 120 - 60}deg)`; // More rotation
                container.appendChild(confetti);
            }
        }

        // Start Everything
        try {
            createBalloons(); // Create balloons
            animate();        // Start animation loop
            createConfetti(); // Create CSS confetti
        } catch(error) {
             console.error("Error starting animation or effects:", error);
             // Fallback handled during renderer init
        }

    </script>

</body>
</html>
