<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>致Isaure：生日星光闪耀！</title>

    <!-- Embedded CSS Styles -->
    <style>
        /* ... (Keep all existing CSS rules - no changes needed here for this request) ... */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap');

        :root {
            --primary-color: #ff69b4; /* Hot Pink */
            --secondary-color: #dda0dd; /* Plum */
            --accent-color: #ffd700; /* Gold */
            --text-color: #f0f8ff; /* Alice Blue */
            --bg-color-start: #1a001a; /* Deep Purple - Fallback */
            --card-bg-color: rgba(26, 0, 26, 0.7); /* More opaque card */
            --card-blur: 12px; /* Increased blur */
            --glow-intensity: 0.8; /* Glow effect intensity */
        }

        html {
            scroll-behavior: smooth;
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Noto Serif SC', serif;
            color: var(--text-color);
            background-color: var(--bg-color-start);
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        /* Three.js Canvas Styling */
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            display: block;
        }

        /* Content Overlay with gradient overlay */
        .content-overlay {
            position: relative;
            z-index: 1;
            padding-top: 5vh;
            padding-bottom: 5vh;
        }

        /* Container for centered content */
        .container {
            max-width: 850px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Enhanced Content Card Styling with Stronger Shadow */
        .content-card {
            background: var(--card-bg-color);
            border-radius: 20px;
            padding: 35px 45px;
            margin-bottom: 45px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.85); /* STRONGER SHADOW */
            backdrop-filter: blur(var(--card-blur));
            -webkit-backdrop-filter: blur(var(--card-blur));
            border: 1px solid rgba(255, 255, 255, 0.25);
            animation: fadeInCard 1.2s cubic-bezier(0.25, 1, 0.5, 1) forwards;
            opacity: 0;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .content-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,105,180,0.15) 0%, rgba(255,105,180,0) 65%);
            transform: rotate(30deg) scale(0.8);
            z-index: 0;
            opacity: 0;
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        .content-card:hover {
            box-shadow: 0 25px 65px rgba(0, 0, 0, 0.95); /* STRONGER HOVER SHADOW */
            transform: translateY(-5px);
        }

        .content-card:hover::before {
            opacity: var(--glow-intensity, 0.8);
            transform: rotate(0deg) scale(1);
        }

        /* Card Fade-in Animation */
        @keyframes fadeInCard {
            from { opacity: 0; transform: translateY(50px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* Animation Delays */
        .hero { animation-delay: 0.2s; }
        .about-her { animation-delay: 0.4s; }
        .friendship { animation-delay: 0.6s; }
        .wishes { animation-delay: 0.8s; }

        /* Enhanced Headings */
        h1, h2, h3 {
            text-align: center;
            font-weight: 700;
            letter-spacing: 1px;
            position: relative;
        }

        h1 {
            font-size: calc(2.8rem + 2vw);
            color: var(--accent-color);
            text-shadow: 0 0 15px var(--accent-color), 0 0 30px var(--primary-color), 0 0 50px var(--primary-color);
            margin-bottom: 15px;
            animation: glow 2.5s infinite alternate ease-in-out;
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            padding-bottom: 10px;
        }

        @keyframes glow {
            from { text-shadow: 0 0 15px var(--accent-color), 0 0 30px var(--primary-color), 0 0 45px var(--primary-color); filter: brightness(1); }
            to { text-shadow: 0 0 25px var(--accent-color), 0 0 50px var(--primary-color), 0 0 75px var(--primary-color); filter: brightness(1.2); }
        }

        h2 {
            font-size: calc(2rem + 1.2vw);
            color: var(--secondary-color);
            margin-top: 35px;
            margin-bottom: 30px;
            display: inline-block;
            position: relative;
            left: 50%;
            transform: translateX(-50%);
            padding: 0 20px 15px;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 10%;
            width: 80%;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
            border-radius: 3px;
            opacity: 0.8;
        }

        h2::before {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, var(--secondary-color) 0%, transparent 70%);
            filter: blur(6px);
            opacity: 0.7;
        }

        h3 {
            font-size: calc(1.4rem + 0.6vw);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            color: var(--accent-color);
        }

        /* Enhanced Paragraphs and Lists */
        p, li {
            font-size: calc(1.05rem + 0.3vw);
            line-height: 1.9;
            text-align: justify;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.75);
            margin-bottom: 20px;
            position: relative;
            color: var(--text-color);
        }

        /* Burstiness/Perplexity Styling */
        .burstiness-text p:nth-child(odd) {
            font-size: calc(1.1rem + 0.3vw);
            margin-left: 15px;
            letter-spacing: 0.5px;
            padding-left: 12px;
            border-left: 3px solid rgba(255, 105, 180, 0.4);
        }
        .burstiness-text p:nth-child(even) {
            font-size: calc(1rem + 0.3vw);
            margin-right: 15px;
            font-style: italic;
            opacity: 0.95;
            padding-right: 12px;
            border-right: 3px solid rgba(221, 160, 221, 0.4);
        }
        .burstiness-text p:last-child {
             font-weight: bold;
             color: var(--accent-color);
             text-align: center;
             font-size: calc(1.35rem + 0.4vw);
             margin-top: 35px;
             text-shadow: 0 0 15px var(--accent-color);
             animation: pulse 3s infinite ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.9; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .highlight {
            color: var(--primary-color);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.9);
            position: relative;
            display: inline-block;
            padding-bottom: 2px;
        }

        .highlight::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--primary-color);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .highlight:hover::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        .icon {
            font-size: 1.5em;
            margin-right: 8px;
            vertical-align: -0.15em;
            display: inline-block;
            filter: drop-shadow(0 0 5px var(--secondary-color));
            transition: transform 0.4s ease;
        }

        .icon:hover {
            transform: scale(1.2) rotate(10deg);
        }

        /* Enhanced Button Style */
        .cta-button {
            display: inline-block;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 16px 35px;
            border-radius: 50px;
            text-decoration: none;
            font-weight: bold;
            margin-top: 30px;
            text-align: center;
            transition: all 0.4s ease;
            box-shadow: 0 8px 25px rgba(255, 105, 180, 0.6);
            border: none;
            cursor: pointer;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
            z-index: 1;
            font-size: 1.1em;
            letter-spacing: 1px;
        }

        .cta-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
            transition: transform 0.4s ease;
            transform: scaleX(0);
            transform-origin: left;
            z-index: -1;
        }

        .cta-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(221, 160, 221, 0.8);
            color: #1a001a;
        }

        .cta-button:hover::before {
            transform: scaleX(1);
            transform-origin: left;
        }

        /* Enhanced Footer Styling */
        footer {
             text-align: center;
             padding: 25px 0;
             margin-top: 40px;
             font-size: 1em;
             color: rgba(255, 255, 255, 0.8);
             z-index: 2;
             position: relative;
             text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
             border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        footer::before {
            content: '✨';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.6em;
            filter: drop-shadow(0 0 6px var(--accent-color));
            opacity: 0.9;
            animation: footerSparkle 4s infinite ease-in-out;
        }

        @keyframes footerSparkle {
             0%, 100% { opacity: 0.7; transform: translateX(-50%) scale(1); }
             50% { opacity: 1; transform: translateX(-50%) scale(1.1); }
        }

        /* Floating Confetti Effect (CSS Only) */
        #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 10;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 15px;
            background-color: var(--primary-color);
            opacity: 0;
            animation: confetti-fall 5s linear infinite;
            transform-origin: center center;
            will-change: transform, opacity;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-10vh) rotateZ(0deg) rotateY(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) rotateZ(720deg) rotateY(360deg);
                opacity: 0;
            }
        }

        /* Tablet Optimizations */
        @media (max-width: 1024px) {
            .container { max-width: 90%; padding: 15px; }
            h1 { font-size: calc(2.5rem + 2.2vw); }
            h2 { font-size: calc(1.8rem + 1.4vw); }
            p, li { font-size: calc(1.0rem + 0.35vw); line-height: 1.85; }
            .content-card { padding: 30px 35px; margin-bottom: 40px; }
        }

        @media (max-width: 768px) {
            h1 { font-size: calc(2.3rem + 2.8vw); }
            h2 { font-size: calc(1.6rem + 1.8vw); margin-bottom: 25px;}
            p, li { font-size: calc(0.95rem + 0.45vw); line-height: 1.8; margin-bottom: 18px;}
            .content-card { padding: 25px 30px; margin-bottom: 35px;}
            .burstiness-text p:nth-child(odd) { margin-left: 10px; padding-left: 8px; }
            .burstiness-text p:nth-child(even) { margin-right: 10px; padding-right: 8px; }
            .cta-button { padding: 14px 30px; font-size: 1em; }
        }
    </style>

    <!-- Import Map for Three.js Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
                "three/geometries/":"https://app.unpkg.com/three@0.163.0/files/examples/jsm/geometries"
            }
        }
    </script>

</head>
<body>

    <!-- Three.js Canvas Container -->
    <canvas id="three-canvas"></canvas>

    <!-- Confetti Container (Now styled with CSS) -->
    <div id="confetti-container"></div>

    <!-- HTML Content Overlay -->
    <div class="content-overlay">
        <div class="container">

            <!-- 生日祝福头部 -->
            <header class="content-card hero" id="top">
                <h1>Isaure！</h1>
                <p style="text-align: center; font-size: 1.3em; color: var(--secondary-color); text-shadow: 0 0 10px var(--secondary-color);">今天，宇宙为你特别调亮了星辰！✨</p>
                <p style="text-align: center; font-style: italic; font-size: 1.1em;">这绝非日历上庸常的一页翻过，<br>这是独属于你的，盛放的，<span class="highlight">光芒四射</span>的时刻！</p>
                <h3 style="text-align: center; color: var(--accent-color); margin-top: 20px; animation: pulse 2s infinite;">生日快乐，Dear Isaure</h3>
            </header>

            <!-- 关于她的光芒 -->
            <section class="content-card about-her burstiness-text">
                <h2><span class="icon">☀️</span>关于你的光芒与斑斓</h2>
                <p>你的笑靥，恰似盛夏破晓时那第一缕最无遮拦的阳光，总能轻易地融化积雪，驱散阴霾，明媚得叫人心生暖意，世界为之一亮。外向？开朗？这些词语固然捕捉了你的部分剪影，却又怎能穷尽你灵魂深处那股奔涌不息、近乎野性的生命热力！你，就像一颗蕴藏着宇宙洪荒能量的星核，时刻准备着，要爆发出最不可思议的绚烂华彩。</p>
                <p>我知道，这世界并非总是铺满玫瑰与丝绒，这个世界带来的阴影或许曾让你步履蹒跚，留下难以言说的刻痕。但请你看看自己——看啊！那些过往的风霜，或许曾经打败了你 但我来了</p>
                <p>而当你全然沉浸于挚爱之事——<span class="icon">🎤</span>放声歌唱时，那歌声，时而是穿透云霭的清冽山泉，流淌着抚慰人心的温柔；时而是掀起风暴的海潮，蕴含着震撼灵魂的力量，每一个音符都仿佛被赋予了生命，在空气中舞蹈、回旋。<span class="icon">🎨</span>挥动画笔时，你的指尖便拥有了点石成金的魔法，色彩在你手中不再仅仅是颜料，它们是情绪的载体，是梦想的碎片，是你在画布上构建的一个又一个平行宇宙，那里光风霁月，鸟语花香，是你内心深处不灭的理想国。</p>
                <p>你的才华，不是孤芳自赏的水仙，而是黑夜中指引航船的灯塔，既照亮了自己前行的路，也温暖了所有靠近你的人。</p>
            </section>

            <!-- 我们的友谊 -->
            <section class="content-card friendship burstiness-text">
                <h2><span class="icon">💖</span>我们之间，是超越定义的羁绊</h2>
                <p>我们曾并肩作战、抵御风浪的同袍，那些一起熬过的夜，一起攻克的难关，都已化作彼此心中无需言说的默契；我们更是交换心事、分享脆弱的知己，那些深夜月光下的窃窃私语，那些只有我们才懂的梗和瞬间，早已成为灵魂深处最温暖的秘藏。知道吗？无论顺境逆旅，总有一个角落为你留着，总有一个声音对你说："我永远懂你 抱抱"</p>
                <p>是你，教会我释放压力；也是你，让我深刻体会到，即便身处幽谷，也要永远向着阳光的方向，倔强生长。你在我绝望的时候从深渊中把我拉起，甚至不惜自己。这份友谊，它坚韧过最硬的钻石，温暖过冬日的炉火，纯粹过初生的朝露——能遇见你，是我此生何其幸運的恩典。真的，千言万语，汇成一句：谢谢你，出现在我的生命里！</p>
                <p>这份情谊，早已超越"友谊"二字的简单界定，它是一种深刻、复杂的的连接，一种灵魂的回响，在岁月的长河里熠熠生辉，历久弥坚。</p>
            </section>

            <!-- 温柔的鼓励与祝福 -->
            <section class="content-card wishes burstiness-text">
                <h2><span class="icon">🌟</span>愿你的世界，从此晴空万里，繁花似锦</h2>
                <p>Dear Isaure，我知道的，生活这本厚重的书，并非每一页都写满了诗情画意。那些不期而至的风雨，那些沉甸甸压在心头的往事，或许让你感到疲惫，甚至偶有瞬间的黯淡。但请你务必坚信——你内在蕴藏的那束光，那独一无二的灵魂火焰，从未有熄灭！即便他似乎快要熄灭了，我哪怕将自己作为那些豆萁，也要将你推向美好的未来。</p>
                <p>过去的伤痕，它们塑造了你的一部分，却绝不能定义你的全部！你那颗强大而温柔的心，你对艺术与美的执着热爱，你创造快乐、感染他人的非凡能力——这，这才是你最真实、最宝贵的内核！是那个唱歌时眼里有星河璀璨，画画时指尖有蝶舞翩跹的你！不要，永远不要让任何阴霾遮蔽了你眺望远方的视线。你看，前方是多么辽阔无垠的天地，正等待你用最嘹亮的歌声去回应，用最绚烂的色彩去描绘！去拥抱！去征服！</p>
                <p>所以，今天，这个特殊的日子，以及未来每一个值得庆祝的平凡瞬间，请你<span class="highlight">无所顾忌地放声歌唱吧！淋漓尽致地挥洒你的色彩吧！</span>去做一切能点燃你热情、让你心跳漏掉半拍、让你嘴角不自觉上扬的事情！勇敢去爱，热烈去感受，大胆去创造，书写只属于你的、独一无二的生命传奇！</p>
                <p>愿快乐从此成为你的日常标配，像空气一样无处不在；愿温暖时刻将你紧紧环绕，如同最贴身的拥抱；愿世间所有不期而遇的美好，都争先恐后地向你奔涌而来，汇聚成幸福的海洋！愿你的每一天，都充满意想不到的惊喜与不容置疑的好运！<br>生日快乐，我心中无可替代的Isaure！<br>愿你的世界，自此只有斑斓色彩，再无一丝阴霾！</p>
                <div style="text-align: center;">
                    <a href="#top" class="cta-button" onclick="document.getElementById('top').scrollIntoView({ behavior: 'smooth' }); return false;">回到星光之巅！</a>
                </div>
            </section>

            <!-- 页脚 -->
             <footer>
                用漫天星辰作墨，写下这份祝福，<br>
                送给独一无二的你，我最好的朋友。
            </footer>
             <p style="font-size: 0.65em; /* 调整为你想要的精确大小 */
                      color: rgba(255, 255, 255, 0.7); /* 白色带一点透明 */
                      text-align: center;
                      margin-top: 20px; /* 与页脚的距离 */
                      padding-bottom: 15px; /* 距离页面底部的距离 */
                      opacity: 0.8; /* 轻微透明 */
                      letter-spacing: 0.5px; /* 轻微增加字间距 */
                      position: relative; /* 确保在canvas之上 */
                      z-index: 2;">
                最后 You're the only one I want to give the most affection to.
            </p>
        </div>
    </div>

    <!-- Embedded Three.js Script (Module Type) -->
    <script type="module">
        import * as THREE from 'three'; // Imports the core library
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/geometries/TextGeometry.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
        // No need for the 'three/src/' imports here
        // Scene Setup
        const scene = new THREE.Scene();
        const canvas = document.getElementById('three-canvas');
        let renderer, composer, bloomPass;
        let textMesh = null;
        // Use THREE.TextureLoader because TextureLoader is part of the core THREE object
        const textureLoader = new THREE.TextureLoader();


        try {
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.25; // Slightly increased exposure for vibrancy
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        } catch (error) {
            console.error("WebGL is not supported or renderer initialization failed:", error);
            // Fallback message display logic (same as before)
            const overlay = document.querySelector('.content-overlay');
            if (overlay) overlay.style.display = 'none';
            document.body.innerHTML = "<div style='color:white; text-align:center; padding: 50px; font-size: 1.2em; font-family: sans-serif;'>抱歉，您的设备似乎不支持创建这个3D效果所需的技术(WebGL)。<br>但这份生日祝福的心意不变！生日快乐，Isaure！</div>" + (overlay ? overlay.outerHTML : '');
            if(canvas) canvas.style.display = 'none';
            throw new Error("Renderer failed to initialize.");
        }

        // Camera
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 3000); // Increased far plane for nebula
        camera.position.set(0, 20, 85); // Adjusted camera start

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.04;
        controls.enableZoom = true;
        controls.zoomSpeed = 0.6;
        controls.enablePan = false;
        controls.minDistance = 30;
        controls.maxDistance = 250; // Allow zooming out further
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.35; // Slightly slower auto-rotate
        controls.maxPolarAngle = Math.PI * 0.88;
        controls.minPolarAngle = Math.PI * 0.12;

        // --- Enhanced Lighting & Lens Flares ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.65); // Slightly brighter ambient
        scene.add(ambientLight);

        // --- Placeholder Textures - REPLACE THESE URLS! ---
        const texFlare1 = textureLoader.load( '/path/to/lensflare0.png' ); // Circle glow
        const texFlare2 = textureLoader.load( '/path/to/lensflare2.png' ); // Generic flare
        const texFlare3 = textureLoader.load( '/path/to/lensflare3.png' ); // Hexagonal flare

        // Pink Light + Flare
        const pointLight1 = new THREE.PointLight(0xff69b4, 500, 400, 1.7); // Adjusted params
        pointLight1.position.set(90, 70, 90);
        pointLight1.castShadow = true;
        pointLight1.shadow.mapSize.width = 1024;
        pointLight1.shadow.mapSize.height = 1024;
        pointLight1.shadow.camera.near = 10;
        pointLight1.shadow.camera.far = 450;
        pointLight1.shadow.bias = -0.002; // Fine-tune bias
        scene.add(pointLight1);
        addLensflare(pointLight1, 0.6, texFlare1, texFlare3); // Add flare to this light

        // Plum Light + Flare
        const pointLight2 = new THREE.PointLight(0xdda0dd, 400, 350, 1.8);
        pointLight2.position.set(-90, -70, 70);
        // pointLight2.castShadow = true; // Optional shadows
        scene.add(pointLight2);
        addLensflare(pointLight2, 0.4, texFlare1, texFlare3); // Add flare

        // Gold Light + Flare
        const pointLight3 = new THREE.PointLight(0xffd700, 350, 350, 1.8);
        pointLight3.position.set(0, -80, 140);
        // pointLight3.castShadow = true; // Optional shadows
        scene.add(pointLight3);
        addLensflare(pointLight3, 0.5, texFlare1, texFlare2); // Add flare

        // Helper function to add lens flares
        function addLensflare(light, scale, tex1, tex2) {
            const lensflare = new Lensflare();
            // Main glow
            lensflare.addElement( new LensflareElement( tex1, 512 * scale, 0, light.color.clone().multiplyScalar(0.8) ) );
            // Smaller hexagonal elements
            lensflare.addElement( new LensflareElement( tex2, 60 * scale, 0.6 ) );
            lensflare.addElement( new LensflareElement( tex2, 70 * scale, 0.7 ) );
            lensflare.addElement( new LensflareElement( tex2, 120 * scale, 0.9 ) );
            lensflare.addElement( new LensflareElement( tex2, 70 * scale, 1 ) );
            light.add( lensflare ); // Attach flare to the light source
        }

        // Light Halos (same as before)
        const lightHalo1 = createLightHalo(0xff69b4, 20); lightHalo1.position.copy(pointLight1.position); scene.add(lightHalo1);
        const lightHalo2 = createLightHalo(0xdda0dd, 17); lightHalo2.position.copy(pointLight2.position); scene.add(lightHalo2);
        const lightHalo3 = createLightHalo(0xffd700, 15); lightHalo3.position.copy(pointLight3.position); scene.add(lightHalo3);
        function createLightHalo(color, size) { /* ... (same function as before) ... */
            const geometry = new THREE.SphereGeometry(size, 32, 16);
            const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false });
            return new THREE.Mesh(geometry, material);
        }


        // Post-processing (Bloom)
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.45, 0.6, 0.65); // Adjusted bloom params
        composer.addPass(bloomPass);


        // --- NEW: Nebula Background ---
        const nebulaTexture = textureLoader.load('/path/to/nebula.jpg'); // <<< REPLACE URL!
        nebulaTexture.wrapS = THREE.RepeatWrapping; // Optional: Tiling if needed
        nebulaTexture.wrapT = THREE.RepeatWrapping;
        const nebulaMaterial = new THREE.MeshBasicMaterial({
            map: nebulaTexture,
            side: THREE.BackSide, // Render on the inside of the sphere
            fog: false // Ignore scene fog
        });
        const nebulaGeometry = new THREE.SphereGeometry(1500, 64, 32); // Large sphere
        const nebulaMesh = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
        nebulaMesh.rotation.y = Math.PI / 4; // Initial rotation
        scene.add(nebulaMesh);


        // Particle System 1: Galaxy (same core logic, adjusted params)
        const particleCount1 = 20000; // More particles
        const particlesGeometry1 = new THREE.BufferGeometry();
        // ... (Arrays: posArray1, colorArray1, sizeArray1) ...
        const posArray1 = new Float32Array(particleCount1 * 3);
        const colorArray1 = new Float32Array(particleCount1 * 3);
        const sizeArray1 = new Float32Array(particleCount1);
        const colorPalette = [ /* ... (same colors) ... */
            new THREE.Color(0xff69b4), new THREE.Color(0xdda0dd), new THREE.Color(0xffd700),
            new THREE.Color(0x9370db), new THREE.Color(0xffffff)
        ];
        for(let i = 0; i < particleCount1; i++) {
            const i3 = i * 3;
            const radius = 180 + Math.random() * 600; // Wider spread
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray1[i3] = radius * Math.sin(phi) * Math.cos(theta);
            posArray1[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            posArray1[i3 + 2] = radius * Math.cos(phi);
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            const finalColor = Math.random() < 0.3 ? (Math.random() < 0.5 ? colorPalette[4] : colorPalette[2]) : color;
            colorArray1[i3] = finalColor.r; colorArray1[i3 + 1] = finalColor.g; colorArray1[i3 + 2] = finalColor.b;
            sizeArray1[i] = Math.random() * 3.2 + 0.9; // Slightly larger range
        }
        particlesGeometry1.setAttribute('position', new THREE.BufferAttribute(posArray1, 3));
        particlesGeometry1.setAttribute('color', new THREE.BufferAttribute(colorArray1, 3));
        particlesGeometry1.setAttribute('size', new THREE.BufferAttribute(sizeArray1, 1));
        const particleMaterial1 = new THREE.PointsMaterial({ /* ... (same material setup) ... */
            vertexColors: true, transparent: true, blending: THREE.AdditiveBlending,
            sizeAttenuation: true, map: createSparkleTexture(), depthWrite: false, alphaTest: 0.01
        });
        const particleSystem1 = new THREE.Points(particlesGeometry1, particleMaterial1);
        scene.add(particleSystem1);


        // --- NEW: Particle System 2 (Ambient Dust/Sparkles) ---
        const particleCount2 = 15000;
        const particlesGeometry2 = new THREE.BufferGeometry();
        const posArray2 = new Float32Array(particleCount2 * 3);
        const colorArray2 = new Float32Array(particleCount2 * 3);
        const sizeArray2 = new Float32Array(particleCount2);
        const dustColor1 = new THREE.Color(0xffffff);
        const dustColor2 = new THREE.Color(0xffeecc); // Warm white

        for(let i = 0; i < particleCount2; i++) {
            const i3 = i * 3;
            // Closer, denser distribution
            const radius = 20 + Math.random() * 150; // Range: 20 to 170
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray2[i3] = radius * Math.sin(phi) * Math.cos(theta);
            posArray2[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            posArray2[i3 + 2] = radius * Math.cos(phi);
            // Mostly white/pale colors
            const color = Math.random() > 0.5 ? dustColor1 : dustColor2;
            colorArray2[i3] = color.r; colorArray2[i3 + 1] = color.g; colorArray2[i3 + 2] = color.b;
            // Smaller sizes
            sizeArray2[i] = Math.random() * 1.5 + 0.3; // Range: 0.3 to 1.8
        }
        particlesGeometry2.setAttribute('position', new THREE.BufferAttribute(posArray2, 3));
        particlesGeometry2.setAttribute('color', new THREE.BufferAttribute(colorArray2, 3));
        particlesGeometry2.setAttribute('size', new THREE.BufferAttribute(sizeArray2, 1));
        const particleMaterial2 = new THREE.PointsMaterial({
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
            map: createSparkleTexture(), // Can use the same texture or a different one
            depthWrite: false,
            alphaTest: 0.01,
            opacity: 0.7 // Slightly less opaque
        });
        const particleSystem2 = new THREE.Points(particlesGeometry2, particleMaterial2);
        scene.add(particleSystem2);


        // Sparkle Texture Function (same as before)
        function createSparkleTexture() { /* ... (same function as before) ... */
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d'); if (!context) return null;
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); gradient.addColorStop(0.15, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.3)'); gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient; context.fillRect(0, 0, 128, 128);
            const texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture;
        }

        // Floating 3D Text (same as before)
        const textLoader = new FontLoader();
        textLoader.load('https://unpkg.com/three@0.163.0/examples/fonts/helvetiker_regular.typeface.json', font => {
            const textGeometry = new TextGeometry('Happy Birthday', { /* ... (same settings) ... */
                 font: font, size: 8, height: 1.5, curveSegments: 16,
                 bevelEnabled: true, bevelThickness: 0.6, bevelSize: 0.3, bevelOffset: 0, bevelSegments: 8
            });
            textGeometry.center();
            const textMaterial = new THREE.MeshStandardMaterial({ /* ... (same material) ... */
                color: 0xff69b4, emissive: 0xdda0dd, emissiveIntensity: 0.35, // Slightly brighter emissive
                metalness: 0.4, roughness: 0.5, flatShading: false
            });
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(0, 5, -15); // Adjusted position
            textMesh.castShadow = true;
            scene.add(textMesh);
        }, xhr => console.log((xhr.loaded / xhr.total * 100) + '% font loaded'), err => console.error('Font loading error:', err));


        // Floating Shapes (same logic, more shapes)
        const shapesGroup = new THREE.Group();
        const shapeGeometries = [ /* ... (same geometries) ... */
             new THREE.IcosahedronGeometry(3.5, 1), new THREE.TorusKnotGeometry(2.5, 0.8, 128, 16),
             new THREE.OctahedronGeometry(3, 1), new THREE.DodecahedronGeometry(3.2, 0),
             new THREE.TorusGeometry(2.8, 1, 20, 60)
        ];
        const shapesCount = 55; // Increased count
        for(let i = 0; i < shapesCount; i++) {
             const geometry = shapeGeometries[i % shapeGeometries.length];
             const material = new THREE.MeshStandardMaterial({ /* ... (same material setup) ... */
                color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                metalness: Math.random() * 0.7, roughness: Math.random() * 0.6 + 0.2,
                transparent: true, opacity: 0.9 + Math.random() * 0.1,
             });
            const shape = new THREE.Mesh(geometry, material);
            const radius = 70 + Math.random() * 120; // Adjusted distribution range
            const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
            shape.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
            shape.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            shape.castShadow = true;
            shape.userData = { /* ... (same animation data structure) ... */
                orbitSpeed: (Math.random() - 0.5) * 0.012, rotationSpeed: (Math.random() - 0.5) * 0.03,
                bobSpeed: Math.random() * 0.9 + 0.5, amplitude: Math.random() * 5 + 2,
                initialY: shape.position.y
            };
            shapesGroup.add(shape);
        }
        scene.add(shapesGroup);


        // --- NEW: Floating Stars ---
        const starsGroup = new THREE.Group();
        const starShape = new THREE.Shape();
        const outerRadius = 2.5;
        const innerRadius = 1.2;
        const numPoints = 5;
        starShape.moveTo(0, outerRadius);
        for (let i = 0; i < numPoints * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i / (numPoints * 2)) * Math.PI * 2;
            starShape.lineTo(Math.sin(angle) * radius, Math.cos(angle) * radius);
        }
        const extrudeSettings = { depth: 0.5, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.1, bevelThickness: 0.1 };
        const starGeometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
        starGeometry.center(); // Center the geometry

        const starMaterials = [
            new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.6, roughness: 0.4, emissive: 0xccaa00, emissiveIntensity: 0.3 }), // Gold
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.5, roughness: 0.5, emissive: 0xaaaaaa, emissiveIntensity: 0.2 }), // Silver/White
            new THREE.MeshStandardMaterial({ color: 0xffacdf, metalness: 0.5, roughness: 0.5, emissive: 0xcc8aad, emissiveIntensity: 0.25 }) // Pinkish
        ];
        const starCount = 40;

        for (let i = 0; i < starCount; i++) {
            const material = starMaterials[i % starMaterials.length];
            const star = new THREE.Mesh(starGeometry, material);
            const radius = 50 + Math.random() * 150; // Similar distribution to shapes
            const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
            star.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
            star.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            star.scale.setScalar(Math.random() * 0.8 + 0.6); // Random size
            star.castShadow = true;
            star.userData = { // Similar animation data
                orbitSpeed: (Math.random() - 0.5) * 0.010, rotationSpeed: (Math.random() - 0.5) * 0.035,
                bobSpeed: Math.random() * 1.0 + 0.4, amplitude: Math.random() * 4 + 1.5,
                initialY: star.position.y
            };
            starsGroup.add(star);
        }
        scene.add(starsGroup);


        // --- NEW: Spiral Ribbons ---
        const ribbonsGroup = new THREE.Group();
        const ribbonColors = [0xff69b4, 0xdda0dd, 0xffd700, 0x87cefa, 0xffffff];
        const numRibbons = 8;
        const ribbonSegments = 150;
        const ribbonRadius = 1.0; // Thickness of the ribbon tube

        for (let i = 0; i < numRibbons; i++) {
            const points = [];
            const startRadius = 10 + Math.random() * 10;
            const endRadius = 80 + Math.random() * 50;
            const spirals = 3 + Math.random() * 4;
            const height = 100 + Math.random() * 60;
            const startY = (Math.random() - 0.5) * 40;
            const phase = Math.random() * Math.PI * 2;

            for (let j = 0; j <= ribbonSegments; j++) {
                const t = j / ribbonSegments; // Parameter 0 to 1
                const radius = startRadius + (endRadius - startRadius) * t;
                const angle = phase + t * Math.PI * 2 * spirals;
                const y = startY + (height * (t - 0.5)); // Goes up and down
                points.push(new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(curve, ribbonSegments, ribbonRadius, 12, false); // 12 radial segments
            const material = new THREE.MeshStandardMaterial({
                color: ribbonColors[i % ribbonColors.length],
                metalness: 0.3,
                roughness: 0.6,
                side: THREE.DoubleSide // Render both sides
            });
            const ribbon = new THREE.Mesh(geometry, material);
            ribbon.castShadow = true;
            ribbonsGroup.add(ribbon);
        }
        ribbonsGroup.rotation.x = 0.2; // Slight tilt
        scene.add(ribbonsGroup);


        // Floating Balloons (same logic, more balloons)
        const balloonsGroup = new THREE.Group();
        const balloonCount = 40; // Increased count
        const balloonColors = [ /* ... (same colors + more) ... */
            0xff69b4, 0xdda0dd, 0xffd700, 0x87cefa, 0x98fb98, 0xffa07a, 0xa0e0e0, 0xffc0cb
        ];
        const balloonSpawnArea = 200; // Wider spawn
        const balloonMaxHeight = 300; const balloonMinHeight = -200;
        function createBalloons() {
            const balloonGeometry = new THREE.SphereGeometry(3.0, 32, 24); // Slightly larger
            balloonGeometry.scale(1, 1.2, 1);
            for (let i = 0; i < balloonCount; i++) {
                 const balloonMaterial = new THREE.MeshStandardMaterial({ /* ... (same material setup) ... */
                    color: balloonColors[Math.floor(Math.random() * balloonColors.length)],
                    metalness: 0.05, roughness: 0.7, transparent: true, opacity: 0.92,
                 });
                const balloon = new THREE.Mesh(balloonGeometry, balloonMaterial);
                balloon.position.x = (Math.random() - 0.5) * balloonSpawnArea;
                balloon.position.z = (Math.random() - 0.5) * balloonSpawnArea;
                balloon.position.y = balloonMinHeight + Math.random() * 140;
                balloon.castShadow = true;
                balloon.userData = { /* ... (same animation data structure) ... */
                    baseYSpeed: Math.random() * 0.1 + 0.07, driftSpeedX: Math.random() * 0.6 + 0.3,
                    driftSpeedZ: Math.random() * 0.6 + 0.3, driftAmplitudeX: Math.random() * 0.07 + 0.03,
                    driftAmplitudeZ: Math.random() * 0.07 + 0.03, initialPhaseX: Math.random() * Math.PI * 2,
                    initialPhaseZ: Math.random() * Math.PI * 2
                };
                balloonsGroup.add(balloon);
            }
            scene.add(balloonsGroup);
        }


        // Animation loop
        const clock = new THREE.Clock();
        const rotationAxis = new THREE.Vector3(0, 1, 0);

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();

            // Animate Nebula Background (Slow rotation)
            nebulaMesh.rotation.y += deltaTime * 0.005;

            // Animate Particle System 1 (Galaxy)
            particleSystem1.rotation.y = elapsedTime * 0.008; // Slower
            particleSystem1.rotation.x = elapsedTime * 0.004;

            // Animate Particle System 2 (Dust)
            particleSystem2.rotation.y = -elapsedTime * 0.015; // Opposite, slightly faster rotation
            particleSystem2.rotation.z = elapsedTime * 0.006;

            // Animate Shapes (Orbit, Rotate, Bob)
            shapesGroup.children.forEach(shape => { /* ... (same animation logic) ... */
                 const { orbitSpeed, rotationSpeed, bobSpeed, amplitude, initialY } = shape.userData;
                 shape.position.applyAxisAngle(rotationAxis, orbitSpeed * deltaTime);
                 shape.position.y = initialY + Math.sin(elapsedTime * bobSpeed + shape.id) * amplitude;
                 shape.rotation.x += rotationSpeed * deltaTime; shape.rotation.y += rotationSpeed * 0.7 * deltaTime; shape.rotation.z += rotationSpeed * 0.4 * deltaTime;
            });

            // Animate Stars (Orbit, Rotate, Bob)
            starsGroup.children.forEach(star => { /* ... (same animation logic as shapes) ... */
                 const { orbitSpeed, rotationSpeed, bobSpeed, amplitude, initialY } = star.userData;
                 star.position.applyAxisAngle(rotationAxis, orbitSpeed * deltaTime);
                 star.position.y = initialY + Math.sin(elapsedTime * bobSpeed + star.id * 1.1) * amplitude; // Use id for phase offset
                 star.rotation.x += rotationSpeed * 0.8 * deltaTime; star.rotation.y += rotationSpeed * deltaTime; star.rotation.z += rotationSpeed * 0.6 * deltaTime;
            });

            // Animate Ribbons (Slow rotation)
            ribbonsGroup.rotation.y += deltaTime * 0.02;
            ribbonsGroup.rotation.z = Math.sin(elapsedTime * 0.2) * 0.1; // Gentle sway

             // Animate Text
             if (textMesh) { /* ... (same animation logic) ... */
                 textMesh.rotation.y = Math.sin(elapsedTime * 0.35) * 0.18;
                 textMesh.position.y = 5 + Math.sin(elapsedTime * 0.55) * 1.8; // Adjusted base Y
             }

             // Animate Balloons
             balloonsGroup.children.forEach(balloon => { /* ... (same animation logic, check bounds) ... */
                 const ud = balloon.userData;
                 balloon.position.y += ud.baseYSpeed * deltaTime * 60;
                 const swayX = Math.sin(elapsedTime * ud.driftSpeedX + ud.initialPhaseX) * ud.driftAmplitudeX;
                 const swayZ = Math.cos(elapsedTime * ud.driftSpeedZ + ud.initialPhaseZ) * ud.driftAmplitudeZ;
                 balloon.position.x += swayX * deltaTime * 60;
                 balloon.position.z += swayZ * deltaTime * 60;
                 if (balloon.position.y > balloonMaxHeight) {
                     balloon.position.y = balloonMinHeight - Math.random() * 40; // Reset lower
                     balloon.position.x = (Math.random() - 0.5) * balloonSpawnArea;
                     balloon.position.z = (Math.random() - 0.5) * balloonSpawnArea;
                     ud.initialPhaseX = Math.random() * Math.PI * 2; ud.initialPhaseZ = Math.random() * Math.PI * 2;
                 }
             });

            controls.update(); // Update controls
            composer.render(); // Render via composer (includes bloom)
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        // CSS Confetti (same logic, maybe more confetti)
        function createConfetti() {
            const container = document.getElementById('confetti-container');
            if (!container) return;
            const colors = [ /* ... (same colors) ... */
                '#ff69b4', '#dda0dd', '#ffd700', '#9370db', '#ffffff', '#87cefa', '#98fb98', '#ffc0cb'
            ];
            const count = 250; // More confetti
            container.innerHTML = '';
            for(let i = 0; i < count; i++) { /* ... (same confetti element creation logic) ... */
                const confetti = document.createElement('div'); confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                const isRect = Math.random() > 0.4;
                confetti.style.width = Math.random() * (isRect ? 7 : 10) + 4 + 'px';
                confetti.style.height = Math.random() * (isRect ? 11 : 7) + 4 + 'px';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.opacity = Math.random() * 0.4 + 0.6;
                confetti.style.animationDuration = Math.random() * 5 + 4 + 's';
                confetti.style.animationDelay = Math.random() * 8 + 's'; // Slightly longer delay potential
                confetti.style.transform = `rotate(${Math.random() * 120 - 60}deg)`; // More rotation
                container.appendChild(confetti);
            }
        }

        // Start Everything
        try {
            createBalloons(); // Create balloons
            animate();        // Start animation loop
            createConfetti(); // Create CSS confetti
        } catch(error) {
             console.error("Error starting animation or effects:", error);
             // Fallback handled during renderer init
        }

    </script>

</body>
</html>
